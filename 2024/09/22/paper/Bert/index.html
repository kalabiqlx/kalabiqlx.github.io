<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Bert原文笔记 | HUI</title><meta name="author" content="HUI"><meta name="copyright" content="HUI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘要： 我们引入了一种名为 BERT 的新的语言表示模型，它代表 Transformers 的双向编码器表示。与最近的语言表示模型不同，BERT 旨在通过联合调节所有层中的左右上下文来预训练未标记文本的深度双向表示。因此，预训练的 BERT 模型只需一个额外的输出层即可进行微调，从而为各种任务（例如问答和语言推理）创建最先进的模型，而无需对特定于任务的架构进行大量修改。 BERT 概念简单，实验结">
<meta property="og:type" content="article">
<meta property="og:title" content="Bert原文笔记">
<meta property="og:url" content="http://example.com/2024/09/22/paper/Bert/index.html">
<meta property="og:site_name" content="HUI">
<meta property="og:description" content="摘要： 我们引入了一种名为 BERT 的新的语言表示模型，它代表 Transformers 的双向编码器表示。与最近的语言表示模型不同，BERT 旨在通过联合调节所有层中的左右上下文来预训练未标记文本的深度双向表示。因此，预训练的 BERT 模型只需一个额外的输出层即可进行微调，从而为各种任务（例如问答和语言推理）创建最先进的模型，而无需对特定于任务的架构进行大量修改。 BERT 概念简单，实验结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/IEKTIWS4.png">
<meta property="article:published_time" content="2024-09-22T06:48:25.000Z">
<meta property="article:modified_time" content="2024-09-22T06:52:36.277Z">
<meta property="article:author" content="HUI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/IEKTIWS4.png"><link rel="shortcut icon" href="/img/122061154_p0_master1200.jpg"><link rel="canonical" href="http://example.com/2024/09/22/paper/Bert/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Bert原文笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-22 14:52:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bronya.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/87788970_p0_master1200.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/IEKTIWS4.png')"><nav id="nav"><span id="blog-info"><a href="/" title="HUI"><img class="site-icon" src="/img/319E33068A7ED73BAE7EB48FCE321DD4.jpg"/><span class="site-name">HUI</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Bert原文笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-22T06:48:25.000Z" title="发表于 2024-09-22 14:48:25">2024-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-22T06:52:36.277Z" title="更新于 2024-09-22 14:52:36">2024-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/">论文</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%BA%E6%96%87/NLP/">NLP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Bert原文笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/09/22/paper/Bert/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2024/09/22/paper/Bert/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>摘要：</h1>
<p>我们引入了一种名为 <strong>BERT</strong> 的新的语言表示模型，它代表 Transformers 的<strong>双向编码器</strong>表示。<span style="color: #ff2020">与最近的语言表示模型不同，BERT 旨在通过联合调节所有层中的左右上下文来预训练未标记文本的深度双向表示。因此，预训练的 BERT 模型只需一个额外的输出层即可进行微调</span>，从而为各种任务（例如<strong>问答</strong>和<strong>语言推理</strong>）创建最先进的模型，而无需对特定于任务的架构进行大量修改。</p>
<p>BERT 概念简单，实验结果更好。它在 11 项自然语言处理任务上获得了最新的结果，包括将 GLUE 分数提高到 80.5%（绝对提高 7.7%）、MultiNLI 准确率提高到 86.7%（绝对提高 4.6%）、SQuAD v1.1问答测试 F1 达到 93.2（绝对提高 1.5 分），SQuAD v2.0 测试 F1 达到 83.1（绝对提高 5.1 分）。</p>
<h1>1.介绍</h1>
<p><span style="color: #ff2020">语言模型的预训练已被证明可以有效改善许多自然语言处理任务</span>。其中包括<strong>句子层面的任务</strong>，例如<strong>自然语言推理</strong>和<strong>释义</strong>，<span style="color: #ff2020">其目的是通过整体分析句子来预测句子之间的关系</span>，以及<strong>token层面的任务</strong>，例如<strong>实体命名</strong>（人名，街道名字）的识别和问答，其中模型需要在token层面产生细粒度的输出。</p>
<p><span style="color: #ff2020">以下是将预训练的语言表示应用于下游任务的两种现有策略：<strong>基于特征</strong>和<strong>微调</strong></span>。</p>
<ul>
<li><strong>基于特征的方法</strong>：例如<strong>ELMo</strong>，使用特定于任务的架构，其中包括将预训练得到的的表示作为附加特征。</li>
<li><strong>微调方法</strong>：例如<strong>生成式预训练变压器（OpenAI GPT</strong>），引入了最少的特定于任务的参数，并通过简单地微调所有预训练参数来对下游任务进行训练。</li>
</ul>
<p>这两种方法在预训练期间都使用相同的目标函数，它们使用单​​向语言模型来学习通用语言表示。</p>
<p>我们认为当前的技术限制了预训练表示的能力，特别是对于微调方法。<span style="color: #ff2020">主要限制是标准语言模型是单向的，这限制了预训练期间可以使用的架构的选择。</span>例如，在 OpenAI GPT 中，作者使用从左到右的架构，其中每个token只能关注 Transformer 的自注意力层中的先前token。这种限制对于<strong>句子层面任务</strong>来说并不是最优的，并且当将基于微调的方法应用于token层面的任务（例如问答）时可能非常有害，因为在这些任务中，从两个方向合并上下文信息是至关重要。</p>
<blockquote>
<p><strong>句子层面任务</strong>：比如判断一个句子的情绪是不是对的，从左看到右和从右看到左都是可以的</p>
</blockquote>
<p>在本文中，我们通过提出 BERT：来自 Transformers 的双向编码器表示来改进基于微调的方法。 BERT 受Cloze任务（Taylor，1953）的启发，采用“<strong>掩码语言模型</strong>”(<strong>MLM</strong>）预训练目标来缓解前面提到的单向性约束。<strong>掩码语言模型</strong>随机屏蔽输入中的一些token，目标函数是基于其上下文来预测那些被屏蔽的token。与从左到右的语言模型预训练不同，MLM 目标使表示能够融合左右上下文，这使我们能够预训练深度双向 Transformer。除了掩码语言模型之外，我们还使用“下一个句子的预测”任务来联合预训练文本对表示。我们论文的贡献如下：</p>
<ul>
<li>
<p>我们证明了双向预训练对于语言表示的重要性。与雷德福等人使用单向语言模型进行预训练不​​同，<span style="color: #ff2020">BERT 使用MLM来实现预训练的深度双向表示。</span>这也与 Peters 等人形成鲜明对比，它使用独立训练的从左到右和从右到左 语言模型的浅层串联。</p>
</li>
<li>
<p>我们表明，<span style="color: #ff2020">预先训练的表示减少了对许多精心设计的任务特定架构的需求。 BERT 是第一个基于微调的表示模型，它在大量句子级和标记级任务上实现了</span>最先进的性能，优于许多特定于任务的架构。</p>
</li>
<li>
<p>BERT 推进了 11 项 NLP 任务的最新技术。代码和预训练模型可在<a target="_blank" rel="noopener" href="https://github.com/google-research/bert%E4%B8%8A%E8%8E%B7%E5%8F%96%E3%80%82">https://github.com/google-research/bert上获取。</a></p>
</li>
</ul>
<blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>将预训练的语言表示应用于下游任务的两种现有策略：<strong>基于特征</strong>和<strong>微调</strong>。</li>
<li>标准语言模型是单向的，这限制了预训练期间可以使用的架构的选择。，在某些语言任务中，利用上下文信息是至关重要的。</li>
<li>BERT模型主要完成两个任务：“<strong>掩码语言模型</strong>&quot;与&quot;<strong>下一个句子预测</strong>”。&quot;掩码语言模型&quot;是指做完形填空时可以看左右的信息；下一个句子预测即给两个句子，判断两个句子在原文中是不是相邻的。</li>
</ul>
</blockquote>
<h1>2. 相关工作</h1>
<p>预训练通用语言表示有着悠久的历史，我们在本节中简要回顾一下最广泛使用的方法。</p>
<h2 id="2-1-无监督的基于特征的方法">2.1 无监督的基于特征的方法</h2>
<p>学习广泛适用的单词表示几十年来一直是一个活跃的研究领域，包括<strong>非神经</strong>和<strong>神经方法</strong>。 预训练的<strong>词嵌入</strong>是现代 NLP 系统不可或缺的一部分，与从头开始学习的嵌入相比，它提供了显着的改进。为了预训练词嵌入向量，使用了从左到右的语言建模目标，以及区分左右上下文中正确和错误单词的目标。</p>
<p>这些方法已推广到更粗的粒度，例如<strong>句子嵌入</strong>或<strong>段落嵌入</strong>。为了训练句子表示，先前的工作使用目标函数对下一个句子的候选进行排名，在给定前一个句子的表示的情况下从左到右生成下一个句子单词，或去噪自动编码器导出的目标。</p>
<p><strong>ELMo</strong>及其前身沿着不同的维度概括了传统的词嵌入研究。他们从从左到右和从右到左的语言模型中提取上下文相关的特征。每个token的上下文表示是从左到右和从右到左表示的串联。当将上下文词嵌入与现有的特定任务架构集成时，ELMo 推进了几个主要 NLP 基准的最新技术，包括<strong>问答</strong>，<strong>情感分析</strong>和<strong>命名实体识别</strong>。梅拉穆德等人(2016) 提出通过使用 LSTM 从左右上下文预测单个单词的任务来学习上下文表示。与 ELMo 类似，他们的模型是基于特征的，而不是深度双向的。费杜斯等人 (2018) 表明完形填空任务可用于提高文本生成模型的鲁棒性。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Magical_Bubble/article/details/89160032">ELMo解读（论文 + PyTorch源码）_elmo论文-CSDN博客</a></p>
</blockquote>
<h2 id="2-2-无监督微调方法">2.2 无监督微调方法</h2>
<p>与基于特征的方法一样，(Collobert and Weston, 2008)第一个在这个方向上仅使用来自未标记的文本来预训练词嵌入参数。</p>
<p>最近，产生上下文标记表示的句子或文档编码器都是根据未标记的文本进行预训练，然后在监督下游任务进行微调。<span style="color: #ff2020">这些方法的优点是几乎不需要从头开始学习参数。</span>至少部分由于这一优势，OpenAI GPT在 GLUE 基准测试的许多句子级任务上取得了先前最先进的结果。<span style="color: #ff2020">从左到右的语言模型——<strong>编码和自动编码器</strong>目标已用于预训练此类模型</span>。</p>
<h2 id="2-3-从有标记的数据上做迁移学习">2.3 从有标记的数据上做迁移学习</h2>
<p>还有一些工作展示了从具有大型数据集的监督任务中的有效迁移，例如<strong>自然语言推理</strong>和<strong>机器翻译</strong>。计算机视觉研究还证明了从大型预训练模型中进行迁移学习的重要性，其中一个有效的方法是对使用 ImageNet 预训练的模型进行微调。</p>
<blockquote>
<p><span style="color: #4eb31c">BERT以及它之后的一系列工作证明了在NLP上面需要没有标号的大量的数据集，效果比你在有标号的，相对来说小一点的数据上训练模型效果更好</span></p>
</blockquote>
<h1>3. BERT</h1>
<p>我们在本节中介绍 BERT 及其详细实现。<span style="color: #ff2020">我们的框架有两个步骤：<strong>预训练</strong>和<strong>微调</strong>。在预训练期间，模型在不同的预训练任务中使用未标记的数据进行训练。对于微调，BERT 模型首先使用预训练的得到的权重进行初始化，然后使用来自下游任务的标记数据对<strong>所有权重</strong>进行微调。</span>每个下游任务都有单独的微调模型，即使它们是使用相同的预训练权重进行初始化的。图 1 中的问答示例将作为本节的运行示例。</p>
<p><span style="color: #ff2020">BERT 的一个显着特点是其跨不同任务的统一架构</span>。有的预训练架构和最终下游架构之间存在较大差异。</p>
<p><strong>模型架构。</strong><span style="color: #ff2020">BERT 的模型架构是一个多层双向 Transformer 编码器</span>，基于 Vaswani 等人描述的并在tensor2tensor库中发布的原始实现。由于Transformers的使用已经变得普遍，并且我们的实现几乎与原始版本相同，因此我们将省略模型架构的详尽背景描述，并建议读者参考Vaswani等人(2017) 以及优秀的指南，例如“The Annotated Transformer”。</p>
<p>在这项工作中，我们将层数（即 Transformer 块）表示为L，隐藏层大小表示为H，自注意力头的数量表示为 A（在所有情况下，我们将前馈/滤波器大小设置为 4H，即 3072 for the H = 768 and 4096 for the H = 1024）. 我们主要报告两种模型大小的结果：<strong>BERT<sub>BASE</sub></strong>（L= 12，H=768，A=12，总参数=110M）和<strong>BERT<sub>LARGE</sub></strong>（L=24，H=1024，A=16，总参数=340M）。</p>
<blockquote>
<p><span style="color: #4eb31c">bert模型的复杂度与L是线性关系，与H是平方的关系,因为深度增加了两倍，所以宽度平方后增加两倍，A变为16是因为每个头的维度都固定在了64。这里参数大小计算的原理如图所示：首先嵌入层是一个矩阵，它的输入是字典的大小30k，bert用的<strong>WordPiece embbeding</strong>，vocabulary中有30k个token，输出是隐藏单元的个数即H,QKV三个矩阵大小都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>∗</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">H*H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>之后add#norm矩阵大小也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>∗</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">H*H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span>,参数量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>2</mn></msup><mo>∗</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">H^{2}*4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>,再往上是MLP，feed forward输入是H，输出是4H，add#norm输入是4H，输出是H，加起来是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>2</mn></msup><mo>∗</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">H^{2}*8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>，同时有L个transformer块，总参数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi>k</mi><mo>∗</mo><mi>H</mi><mo>+</mo><mi>L</mi><mo>∗</mo><msup><mi>H</mi><mn>2</mn></msup><mo>∗</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">30k*H+L*H^{2}*12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">30</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span></span></p>
<p><strong>WordPiece embbeding</strong>:</p>
<p><img src="NBK88KN3.jpg" alt="img alt=&quot;&quot; data-attachment-key=&quot;NBK88KN3&quot; width=&quot;493&quot; height=&quot;399&quot; src=&quot;attachments/NBK88KN3.jpg&quot; ztype=&quot;zimage&quot;&gt;"></p>
<p><img src="8RHRGJYN.jpg" alt="img alt=&quot;&quot; data-attachment-key=&quot;8RHRGJYN&quot; width=&quot;1546&quot; height=&quot;668&quot; src=&quot;attachments/8RHRGJYN.jpg&quot; ztype=&quot;zimage&quot;&gt;"></p>
</blockquote>
<p>为了进行比较，<strong>BERT<sub>BASE</sub></strong> 的选择与 <strong>OpenAI GPT</strong> 具有相同的模型大小。然而，重要的是，BERT Transformer 使用双向自注意力，而 GPT Transformer 使用<strong>受限自注意力</strong>，其中每个标记只能关注其左侧的上下文。</p>
<p><strong>输入/输出</strong>为了使 BERT 处理各种下游任务，我们的输入能够在一个 token 序列中明确表示为单个句子和一对句子（例如，〈问题，答案〉）。<span style="color: #ff2020">在整个工作中，“<strong>句子</strong>”可以是一段连续的文字，而不是实际的语言句子。 “<strong>序列</strong>”是指 BERT 的输入 token 序列，它可以是单个句子，也可以是打包在一起的两个句子</span>。</p>
<blockquote>
<p><span style="color: #4eb31c">与transformer的不同：Transformer训练的时候它的输入是一个序列对，因为它的编码器解码器会分别输入一个序列，但是bert这个地方只有一个编码器，所以为了应对处理两个句子的情况，需要把两个句子变成一个序列</span></p>
</blockquote>
<p>我们使用具有 30,000 个token词汇的<strong>WordPiece 嵌入</strong>。<span style="color: #ff2020">每个序列的第一个标记始终是一个特殊的分类标记（[CLS]）</span>。与该标记对应的最终隐藏状态用作分类任务的聚合序列表示。<span style="color: #ff2020">句子对被打包成一个序列。我们以两种方式区分句子。首先，我们用一个特殊的标记（[SEP]）将它们分开</span>。<span style="color: #ff2020">其次，我们向每个token加入可学习的嵌入，指示它属于句子 A 还是句子 B。如图 1 所示，我们将输入嵌入表示为 E，将特殊 [CLS] 标记的最终隐藏向量表示为 C ∈ R<sup>H</sup> ，第 i 个输入标记的最终隐藏向量为 Ti ∈ R<sup>H</sup></span>。</p>
<blockquote>
<p><span style="color: #4eb31c">wordpiece的想法是如果一个词在整个词典里面出现概率不大的话，应该把这个词切开看子序列，这个子序列很有可能是词根，出现次数很多，这样词典就会比较小，减少了模型的总参数量。CLS对应的输出，BERT希望它最后表示的是一整个序列的信息，因为BERT使用的是Transformer的编码器，没有解码器中的mask，故每个词可以看到其他所有词的信息，所以CLS可以放在第一个，因为它也能看到整个句子的信息。</span></p>
</blockquote>
<p><img src="../themes/butterfly/source/img/IEKTIWS4.png" alt="img alt=&quot;&quot; data-attachment-key=&quot;IEKTIWS4&quot; width=&quot;1285&quot; height=&quot;523&quot; src=&quot;attachments/IEKTIWS4.png&quot; ztype=&quot;zimage&quot;&gt;"></p>
<p>图 1：BERT 的整体预训练和微调程序。除了输出层之外，预训练和微调都使用相同的架构。使用相同的预训练模型参数来初始化不同下游任务的模型。在微调过程中，所有参数都会被微调。 <strong>[CLS]</strong> 是添加在每个输入示例前面的特殊符号，<strong>[SEP]</strong> 是特殊的分隔符标记（例如分隔问题/答案）。</p>
<blockquote>
<p><span style="color: #4eb31c">token进入bert得到它的embedding表示，bert中最后一个transformer块的输出就是词元的bert表示</span></p>
</blockquote>
<p>对于给定的token，其输入表示是通过对相应的token、段<span style="color: #4eb31c">（在哪一个句子，A还是B）</span>和位置<span style="color: #4eb31c">（次元在序列中的位置信息）</span>嵌入求和来构造的。这种结构的可视化如图 2 所示。</p>
<p><img src="RVV3STGP.png" alt="img alt=&quot;&quot; data-attachment-key=&quot;RVV3STGP&quot; width=&quot;1066&quot; height=&quot;316&quot; src=&quot;attachments/RVV3STGP.png&quot; ztype=&quot;zimage&quot;&gt;"></p>
<center>图 2：BERT 输入表示。输入嵌入是token嵌入、分割嵌入和位置嵌入的总和。</center>
<h2 id="3-1-预训练BERT">3.1 预训练BERT</h2>
<p>与彼得斯等人 (2018a) 和 Radford 等人 (2018)不同，我们不使用传统的从左到右或从右到左的语言模型来预训练 BERT。相反，<span style="color: #ff2020">我们使用本节中描述的<strong>两个无监督任务</strong>来预训练 BERT</span>。此步骤如图 1 的左侧部分所示。</p>
<p><strong>任务1:Masked LM</strong></p>
<p><span style="color: #ff2020">直观上，我们有理由相信<strong>深度双向模型</strong>比从左到右模型或从左到右和从右到左模型的浅层串联更强大。不幸的是，标准条件语言模型只能从左到右或从右到左进行训练，因为双向条件允许每个单词间接“看到自己”，并且该模型可以简单地以多层语境的方式预测目标单词。</span></p>
<p><span style="color: #ff2020">为了训练深度双向表示，我们只需随机mask一定比例的输入token，然后预测这些mask token。</span>我们将此过程称为“<strong>掩码 LM</strong>”（<strong>MLM</strong>），尽管它在文献中经常被称为完形填空任务。在这种情况下，与mask token相对应的最终隐藏向量被输入到词汇表上的输出 softmax 中，就像在标准 LM 中一样。在我们所有的实验中，我们随机屏蔽每个序列中15%的 WordPiece token的。<span style="color: #ff2020">与去噪自动编码器（Vincent et al., 2008）相比，我们只预测屏蔽词而不是重建整个输入</span>。</p>
<blockquote>
<p><span style="color: #4eb31c">如果一个token是由WordPiece输入的话，它有15%的概率随机替换成一个掩码，但是对于特殊词元，比如第一个次元与分割词元就不做替换</span></p>
</blockquote>
<p><span style="color: #ff2020">虽然这使我们能够获得双向预训练模型，但缺点是我们在预训练和微调之间造成了不匹配，因为替换的token也就是[MASK]在微调期间不会出现。为了缓解这种情况，我们并不总是用实际的 [MASK] token替换“屏蔽”单词。训练数据生成器随机选择 15% 的 token 位置进行预测。如果选择第 i 个token，我们将第 i 个token替换为 (1) 80% 真的把token替换为[MASK] (2) 10% 为随机token (3) 10%为未更改的第 i 个token。然后，Ti 将用于通过交叉熵损失来预测原始token</span>。我们在附录 C.2 中比较了该过程的变体。</p>
<p><strong>任务2:下一个句子预测</strong>（<strong>NSP</strong>）</p>
<p><span style="color: #ff2020">许多重要的下游任务，例如<strong>问答</strong>（QA）和<strong>自然语言推理</strong>（NLI）都是基于理解两个句子之间的关系，而语言建模不能直接捕获这种关系。为了训练理解句子关系的模型，我们预先训练二值化的下一个句子预测任务，该任务可以从任何单语语料库轻松生成。具体来说，当为每个预训练示例选择句子 A 和 B 时，50% 的时候 B 是 A 之后的实际下一个句子（标记为 IsNext），50% 的时间它是来自语料库的随机句子（标记为NotNext）</span>。如图 1 所示，C 用于下一句预测 (NSP)。 尽管它很简单，但我们在第 5.1 节中证明，针对此任务的预训练对 QA 和 NLI 都非常有益。 NSP 任务与 Jernite 等人 (2017)以及 Logeswaran 和 Lee (2018)使用的表征学习目标密切相关 。然而，在之前的工作中，只有句子嵌入被传输到下游任务，其中 BERT 传输所有参数来初始化最终任务模型参数。</p>
<p><strong>预训练数据</strong></p>
<p>预训练过程很大程度上遵循现有的语言模型预训练文献。对于预训练语料库，我们使用 BooksCorpus（8 亿字）（Zhu et al., 2015）和英语维基百科（2,500M 字）。对于维基百科，我们仅提取文本段落并忽略列表、表格和标题。<span style="color: #ff2020">为了提取长的连续序列，使用文档级语料库而不是打乱的句子级语料库（例如 Billion Word Benchmark（Chelba 等人，2013））至关重要。</span></p>
<h2 id="3-2-微调BERT">3.2 微调BERT</h2>
<p><span style="color: #ff2020">微调非常简单，因为 Transformer 中的自注意力机制允许 BERT 通过交换适当的输入和输出来对许多下游任务进行建模，无论它们涉及单个文本还是文本对。</span>对于涉及文本对的应用，常见的模式是在应用双向交叉注意力之前独立编码文本对，例如 Parikh 等人（2016）；徐等人（2017）。相反，<span style="color: #ff2020">BERT 使用自注意力机制来统一这两个阶段，因为使用自注意力对串联文本对进行编码，有效地包括两个句子之间的双向交叉注意力。</span></p>
<blockquote>
<p><span style="color: #4eb31c">就是说bert通过将两个句子放入一个序列输入编码器，使得transformer中的自注意力机制能够相互看到两个句子里的信息，但是在编码器解码器架构中，编码器一般看不到解码器中的东西，bert这一点会更好一些，但是代价在于不能做机器翻译类的任务</span></p>
</blockquote>
<p>对于每个任务，我们只需将特定于任务的输入和输出插入到 BERT 中，并端到端地微调所有参数。在输入端，预训练中的句子 A 和句子 B 类似于 <strong>(1) 释义中的句子对</strong>，<strong>(2) 蕴涵中的假设-前提对</strong>，<strong>(3) 问答中的问题-段落对</strong>，以及 <strong>(4) 文本分类或序列标记中的简并文本-∅对</strong>。在输出处，token表示被馈送到token层面任务的输出层，例如序列标记或问答，并且 [CLS] 表示被馈送到输出层以进行分类，例如蕴涵或情感分析。</p>
<blockquote>
<p><span style="color: #4eb31c">就是说词语方面的下游任务可以用每一个token的输出来做处理，在句子层面的任务比如句子向量提取，句子情感分析的场景可以用CLS的信息来做处理</span></p>
</blockquote>
<p>与预训练相比，微调相对便宜。从完全相同的预训练模型开始，论文中的所有结果最多可以在 1 小时内在单个 Cloud TPU 上复制，或者在 GPU 上几个小时内复制。7 我们在相应的文章中描述了特定于任务的细节第 4 节的小节。更多详细信息请参见附录 A.5。</p>
<h1>4. 实验</h1>
<p>在本节中，我们将展示 BERT 在 11 个 NLP 任务上的微调结果。</p>
<h2 id="4-1-通用语言理解评估（GLUE）">4.1 通用语言理解评估（GLUE）</h2>
<p><strong>通用语言理解评估 (GLUE)</strong> 基准是各种自然语言理解任务的集合。 GLUE 数据集的详细描述包含在附录 B.1 中。</p>
<p>为了在 GLUE 上进行微调，我们如第 3 节中所述表示<span style="color: #ff2020">输入序列（对于单个句子或句子对）</span>，并使用与第一个输入标记（[CLS]）相对应的最终隐藏向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>∈</mo><msup><mi>R</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">C ∈ R^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span> 作为聚合表示。微调过程中引入的唯一新参数是分类层权重 W ∈ R<sup>K×H</sup>，其中K是标签数量。我们用 C 和 W 计算标准分类损失，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>C</mi><msup><mi>W</mi><mi>T</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(softmax(CW^T ))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span>。</p>
<p>我们使用32的批量大小，并对所有 GLUE 任务的数据进行3 轮微调。对于每个任务，我们在开发集上选择最佳的微调学习率（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">4e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> 之间）。此外，对于 BERT<sub>LARGE</sub>，<span style="color: #ff2020">我们发现微调在小数据集上有时不稳定，因此我们运行了几次随机重启并在开发集上选择了最佳模型。通过<strong>随机重启</strong>，我们使用相同的预训练检查点，但执行不同的微调数据洗牌和分类器层初始化。</span></p>
<p>结果如表 1 所示。BERT<sub>BASE</sub> 和 BERT<sub>LARGE</sub> 在所有任务上都大幅优于所有系统，与现有技术相比，平均准确度分别提高了 4.5% 和 7.0%。请注意，除了注意力屏蔽之外，BERT<sub>BASE</sub> 和 OpenAI GPT 在模型架构方面几乎相同。对于规模最大、报道最广泛的 GLUE 任务 MNLI，BERT 获得了 4.6% 的绝对精度提升。在官方 GLUE 排行榜10上，BERT<sub>LARGE</sub> 获得了 80.5 分，而 OpenAI GPT 在撰写本文时获得了 72.8 分。</p>
<p><img src="LZ3MX436.png" alt="img alt=&quot;&quot; data-attachment-key=&quot;LZ3MX436&quot; width=&quot;1297&quot; height=&quot;276&quot; src=&quot;attachments/LZ3MX436.png&quot; ztype=&quot;zimage&quot;&gt;"></p>
<p>表 1：GLUE 测试结果，由评估服务器评分 (<a target="_blank" rel="noopener" href="https://gluebenchmark.com/leaderboard">https://gluebenchmark.com/leaderboard</a>)。每个任务下面的数字表示训练示例的数量。 “平均”列与官方 GLUE 分数略有不同，因为我们排除了有问题的 WNLI 集(见(10) in <a target="_blank" rel="noopener" href="https://gluebenchmark.com/faq.">https://gluebenchmark.com/faq.</a>)。BERT 和 OpenAI GPT 是单模型、单任务。表上显示的是 QQP 和 MRPC 的 F1 分数，STS-B 的 Spearman 相关性，其他任务的准确性分数。我们排除了使用 BERT 作为其组件之一的模型。</p>
<p>我们发现 BERT<sub>LARGE</sub> 在所有任务上都显着优于 BERT<sub>BASE</sub>，尤其是那些训练数据很少的任务。第 5.2 节更深入地探讨了模型大小的影响。</p>
<h2 id="4-2-斯坦福问答数据集-SQuAD-v1-1">4.2 斯坦福问答数据集 (SQuAD v1.1)</h2>
<p>斯坦福问答数据集 (SQuAD v1.1) 是 10 万个众包QA Pair的集合（Rajpurkar 等人，2016）。<span style="color: #ff2020">给出一个问题和一篇来自维基百科的包含答案的段落，任务是预测答案文本在段落中的跨度。</span></p>
<p>如图 1 所示，在问答任务中，我们将输入问题和段落打包为单个序列，其中问题使用 A 嵌入，段落使用 B 嵌入。微调时我们只引入<strong>起始向量</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><msup><mi>R</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">S ∈ R^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span>和<strong>结束向量</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>∈</mo><msup><mi>R</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">E ∈ R^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span> 。计算 Ti 和 S 之间的点积，之后计算段落中所有单词的 softmax： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><msup><mi>e</mi><mrow><mi>S</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mi>i</mi></msub></mrow></msup><mi mathvariant="normal">/</mi><msub><mi mathvariant="normal">Σ</mi><mi>j</mi></msub><msup><mi>e</mi><mrow><mi>S</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mi>j</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">P_i = e^{S·T_{i}}/Σ_{j}e^{S·T_{j}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1274em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mpunct mtight">⋅</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mpunct mtight">⋅</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>，得到单词i作为答案范围开始的概率。类似的公式用于答案范围的末尾。从位置i到位置j的候选跨度的得分定义为S·Ti + E·Tj，并且使用j≥i的最大得分跨度作为预测。训练目标是正确开始位置和结束位置的对数似然之和。我们微调3个epoch，学习率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，批量大小为 32。(注意这里是微调，看图1的右边的图)</p>
<p>表 2 显示了排名靠前的条目以及排名靠前的已发布模型的结果）。 来自SQuAD 排行榜的顶级结果没有可用的最新开源模型的描述，并且允许在训练其模型时使用任何公共数据。<span style="color: #ff2020">因此，我们在模型中使用适度的数据增强，首先在 TriviaQA 上进行微调，然后再在 SQuAD 上进行微调。</span></p>
<p>我们性能最佳的系统在整体性能方面比顶级排行榜系统高出 +1.5 F1，在单个系统方面比顶级排行榜系统高出 +1.3 F1。事实上，我们的单一 BERT 模型在 F1 分数方面优于顶级集成模型。没有TriviaQA微调数据后，我们只损失了0.1-0.4F1，仍然大幅优于所有现有模型。</p>
<p><img src="VN7ZKG69.png" alt="img alt=&quot;&quot; data-attachment-key=&quot;VN7ZKG69&quot; width=&quot;568&quot; height=&quot;490&quot; src=&quot;attachments/VN7ZKG69.png&quot; ztype=&quot;zimage&quot;&gt;"></p>
<center>表 2：SQuAD 1.1 结果。 BERT 集成是 7x 系统，使用不同的预训练检查点和微调种子。</center>
<h2 id="4-3-SQuAD-v2-0">4.3 SQuAD v2.0</h2>
<p>SQuAD 2.0 任务扩展了 SQuAD 1.1 问题定义，<span style="color: #ff2020">允许所提供的段落中不存在简短答案的可能性，从而使问题更加现实。</span></p>
<p>我们使用一种简单的方法来扩展 SQuAD v1.1 BERT 模型来完成此任务。<span style="color: #ff2020">我们将没有答案的问题的答案范围视为以 [CLS] 标记开始和 [CLS] 标记结束</span><span style="color: #4eb31c">（即从第一个CLS到第二个CLS即为没有答案的问题，即句子A）。</span>开始和结束答案跨度位置的概率空间被扩展为包括 [CLS] 标记的位置。为了进行预测，我们将<strong>无答案范围的分数</strong>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>S</mi><mo separator="true">⋅</mo><mi>C</mi><mo>+</mo><mi>E</mi><mo separator="true">⋅</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">s_{null} = S·C + E·C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">ll</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 与<strong>最佳非空范围的分数</strong>进行比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>j</mi></msub><msub><mo>≥</mo><mi>i</mi></msub><mi>S</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mi>i</mi></msub><mo>+</mo><mi>E</mi><mo separator="true">⋅</mo><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s_{i,j}=max_j≥_iS·T_i + E·T_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9221em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">ma</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">≥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>。当$$s_{\hat{i} ,j} &gt; s_{null} + τ$$ 时，我们预测一个非空答案，其中在开发集上选择阈值τ以最大化 F1。我们没有为此模型使用TriviaQA数据。我们微调了 2 个 epoch，学习率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，批量大小为 48。</p>
<p>与之前的排行榜和热门的模型（Sun 等人，2018 年；Wang 等人，2018b）相比的结果如表 3 所示，不包括使用 BERT 作为其组件之一的系统。我们观察到比之前最好的系统 F1 提高了 +5.1。</p>
<p><img src="154428908.png" alt></p>
<center>表 3：SQuAD 2.0 结果。我们排除使用 BERT 作为其组件之一的条目。</center>
<h2 id="4-4-SWAG">4.4 SWAG</h2>
<p>Situations With Adversarial Generations (SWAG) 数据集包含 113k 个句子对完成示例，用于<strong>评估有根据的常识推理</strong>。<span style="color: #ff2020">给定一个句子，任务是在四个选项中选择最合理的延续。</span></p>
<p>在对 SWAG 数据集进行微调时，<span style="color: #ff2020">我们构建了四个输入序列，每个序列包含给定句子（句子 A）和可能的延续（句子 B）的串联。唯一引入的特定于任务的参数是一个向量，其与 [CLS] 标记的表示C点积得到每个选择的分数，该分数通过 softmax 层进行归一化。</span></p>
<p>我们对模型进行了 3 个时期的微调，学习率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，批量大小为 16。结果如表 4 所示。BERT<sub>LARGE</sub> 比作者的baseline ESIM+ELMo 系统高出 27.1%，比 OpenAI GPT 高出 8.3%。</p>
<p><img src="154552111.png" alt></p>
<center>表 4：SWAG 开发和测试精度。 †如 SWAG 论文中所述，人类表现是通过 100 个样本进行测量的。</center>
<h1>5. 消融研究</h1>
<p>在本节中，我们对 BERT 的多个方面进行了消融实验，以便更好地了解它们的相对重要性。额外的消融研究可在附录 C 中找到。</p>
<h2 id="5-1-预训练任务的影响">5.1 预训练任务的影响</h2>
<p><span style="color: #ff2020">我们通过使用与 BERT<sub>BASE</sub>完全相同的预训练数据、微调方案和超参数来评估两个预训练目标，证明了 BERT 深度双向性的重要性：</span></p>
<p><strong>无 NSP</strong>：使用“masked LM”（MLM）训练但没有“下一句预测”（NSP）任务的双向模型。</p>
<p><strong>LTR 和无 NSP</strong>：仅左上下文模型，使用标准从左到右 (LTR) LM 而不是 MLM 进行训练。仅左约束也适用于微调，因为删除它会引入预训练/微调不匹配，从而降低下游性能。此外，该模型是在没有 NSP 任务的情况下进行预训练的。这可以直接与 OpenAI GPT 进行比较，但使用我们更大的训练数据集、我们的输入表示和我们的微调方案。</p>
<p>我们首先考察NSP任务带来的影响。在表 5 中，我们表明删除 NSP 会显着损害 QNLI、MNLI 和 SQuAD 1.1 的性能。接下来，我们通过比较“No NSP”与“LTR &amp; No NSP”来评估训练双向表示的影响。 LTR 模型在所有任务上的表现都比 MLM 模型差，在 MRPC 和 SQuAD 上下降幅度较大。</p>
<p><img src="154135215.png" alt></p>
<p>表 5：使用 BERTBASE 架构对预训练任务的消融。 “No NSP”是在没有下一句预测任务的情况下进行训练的。 “LTR &amp; No NSP”被训练为从左到右的 LM，没有下一句预测，就像 OpenAI GPT 一样。 “+ BiLSTM”在微调过程中在“LTR + No NSP”模型之上添加了一个随机初始化的 BiLSTM。</p>
<p>对于 SQuAD 来说，直观上很明显，LTR 模型在 token 预测方面表现不佳，因为 token 级隐藏状态没有右侧上下文。<span style="color: #ff2020">为了真实地尝试加强 LTR 系统，我们在顶部添加了一个随机初始化的 BiLSTM。这确实显着改善了 SQuAD 的结果，但结果仍然比预训练的双向模型差很多。 BiLSTM 会损害 GLUE 任务的性能</span>。</p>
<p>我们认识到，也可以训练单独的 LTR 和 RTL 模型，并将每个标记表示为两个模型的串联，就像 ELMo 所做的那样。然而：(a) 这比单个双向模型贵两倍； (b) <span style="color: #ff2020">这对于像 QA 这样的任务来说是不直观的，因为 RTL 模型无法根据问题给出答案</span>； © 它严格来说不如深度双向模型强大，因为它可以在每一层使用左右上下文。</p>
<h2 id="5-2-模型规模的影响">5.2 模型规模的影响</h2>
<p>在本节中，我们探讨模型大小对微调任务准确性的影响。我们训练了许多具有不同层数、隐藏单元和注意力头的 BERT 模型，同时使用与前面描述的相同的超参数和训练过程。</p>
<p>所选 GLUE 任务的结果如表 6 所示。在该表中，我们报告了 5 次随机重新启动微调的平均开发集准确度。我们可以看到，更大的模型在四个数据集上都带来了严格的准确率提高，即使对于只有 3,600 个标记训练示例的 MRPC，并且与预训练任务有很大不同。也许令人惊讶的是，我们能够在相对于现有文献已经相当大的模型之上实现如此重大的改进。例如，Vaswani 等人探索的最大的 Transformer。 (2017) 是 (L=6, H=1024, A=16)，编码器有 100M 个参数，我们在文献中找到的最大 Transformer 是 (L=64, H=512, A=2)，有 235M参数。相比之下，BERT<sub>BASE</sub> 包含 110M 参数，BERT<sub>LARGE</sub>包含 340M 参数。</p>
<p><img src="153921515.png" alt></p>
<center>表 6：BERT 模型大小的消融。 #L = 层数； #H = 隐藏尺寸； #A = 注意力头的数量。 “LM (ppl)”是保留训练数据的屏蔽 LM 困惑度。</center>
<p><span style="color: #ff2020">众所周知，增加模型大小将导致机器翻译和语言建模等大规模任务的持续改进，表 6 中所示的保留训练数据的 LM 困惑就证明了这一点。</span>但是，我们相信这是第一项令人信服地证明，只要模型经过充分的预训练，扩展到极端模型大小也能在非常小规模的任务上带来巨大改进。彼得斯等人（2018b）提出将预训练双向LM大小从两层增加到四层对下游任务影响的结果好坏参半，Melamud等人 (2016) 顺便提到，将隐藏维度大小从 200 增加到 600 有帮助，但进一步增加到 1,000 并没有带来进一步的改进。<span style="color: #ff2020">这两项先前的工作都使用了基于特征的方法——我们假设当模型直接在下游任务上进行微调并且仅使用极少数随机初始化的附加参数时，特定于任务的模型可以从更大、更具表现力的预训练中受益，即使下游任务数据非常小，也可以训练表示。</span></p>
<h2 id="5-3-BERT-的基于特征的方法">5.3 BERT 的基于特征的方法</h2>
<p><span style="color: #ff2020">迄今为止提出的所有 BERT 结果都使用了微调方法，其中在预训练模型中添加了一个简单的分类层，并且所有参数在下游任务上联合微调。</span>然而，从预训练模型中提取固定特征的基于特征的方法具有一定的优势。<span style="color: #ff2020">首先，并不是所有的任务都可以很容易地用 Transformer 编码器架构来表示，因此需要添加特定于任务的模型架构。其次，预先计算一次昂贵的训练数据表示，然后在此表示之上使用更便宜的模型运行许多实验，具有重大的计算优势。</span></p>
<p>在本节中，我们通过将 BERT 应用于 CoNLL-2003 <strong>命名实体识别</strong> (<strong>NER</strong>) 任务来比较这两种方法。在 BERT 的输入中，我们使用<strong>保留大小写</strong>的 WordPiece 模型，并包含数据提供的最大文档上下文。按照标准实践，我们将其制定为token层面的任务，但在输出中用CRF层。我们使用第一个sub-token的表示作为NER标签集上token级分类器的输入。</p>
<p>为了删除微调方法，我们应用基于特征的方法，从一层或多层中提取激活，而无需微调 BERT 的任何参数。这些上下文嵌入用作分类层之前随机初始化的两层 768 维 BiLSTM 的输入。</p>
<p>结果如表 7 所示。BERT<sub>LARGE</sub> 的表现与最先进的方法相当。<strong>性能最佳的方法</strong>:把预训练 Transformer 的前四个隐藏层的 token 表示连接起来，这仅比微调整个模型慢了 0.3 F1。这表明 BERT 对于微调和基于特征的方法都是有效的。</p>
<p><img src="153745636.png" alt></p>
<center>表 7：CoNLL-2003 命名实体识别结果。使用开发集选择超参数。报告的开发和测试分数是使用这些超参数进行 5 次随机重启的平均值。</center>
<h1>6. 结论</h1>
<p>近期由于语言模型的迁移学习而取得的实证改进表明，<span style="color: #ff2020">丰富的、无监督的预训练是许多语言理解系统不可或缺的一部分。</span>特别是，这些结果甚至使低资源任务也能从深度单向架构中受益。<span style="color: #ff2020">我们的主要贡献是将这些发现进一步推广到深层双向架构，从而使相同的预训练模型能够成功处理广泛的 NLP 任务</span>。</p>
<blockquote>
<p><span style="color: #4eb31c">两个前面的工作，一个是ELMo，它用了双向的信息，但是它的网络结构是比较老的RNN，另一个是GPT，它用了一个新一点的transformer的架构，但是它只能处理单向的信息把ELMo使用双向信息的方法与gpt使用的transformer合起来就成了BERT，做语言模型时不是预测未来而是变成完形填空</span></p>
</blockquote>
<h1>附录：</h1>
<h1>A.BERT的附加细节</h1>
<h2 id="A-1-预训练任务说明">A.1 预训练任务说明</h2>
<p>我们在下面提供预训练任务的示例。</p>
<p><strong>掩码LM和掩码过程</strong>:假设未标记的句子是my dog is hairy，并且在随机掩码过程中我们选择了第4个token（对应于毛茸茸的），我们的掩码过程可以进一步如下表示：</p>
<p><img src="R5YIXP69.png" alt="img alt=&quot;&quot; data-attachment-key=&quot;R5YIXP69&quot; width=&quot;574&quot; height=&quot;457&quot; src=&quot;attachments/R5YIXP69.png&quot; ztype=&quot;zimage&quot;&gt;"></p>
<p>此过程的优点是 Transformer 编码器不知道将要求预测哪些单词或哪些单词已被随机单词替换，因此它被迫保留每个输入token的分布式上下文表示。此外，由于随机替换仅发生在所有token的 1.5%（即 15% 的 10%）中，因此这似乎不会损害模型的语言理解能力。在 C.2 节中，我们评估了该操作的影响。</p>
<p><font color="red">与标准语言模型训练相比，Masked LM 仅对每batch中15%的 token 进行预测，这表明模型可能需要更多的预训练步骤来收敛。在 C.1 节中，我们证明 MLM 的收敛速度确实比从左到右的模型（预测每个 token）稍慢，但 MLM 模型的学习效果远远超过了增加的训练成本。</font></p>
<p><img src="150621453.png" alt></p>
<p>图 3：预训练模型架构的差异。 <strong>BERT</strong> 使用双向 Transformer。 <strong>OpenAI GPT</strong> 使用从左到右的 Transformer。 <strong>ELMo</strong> 使用独立训练的从左到右和从右到左 LSTM 的串联来生成下游任务的特征。在这三者中，只有 BERT 表示在所有层中同时以左右上下文为条件。除了架构差异之外，BERT 和 OpenAI GPT 是<strong>微调方法</strong>，而 ELMo 是<strong>基于特征的方法</strong>。</p>
<p><strong>下一句预测</strong>:下一句预测任务可以通过以下示例进行说明。</p>
<p><img src="151142249.png" alt></p>
<blockquote>
<p><span style="color: #4eb31c">##表示在原文中是跟着前面的那个词，这里就是WordPiece中划分的例子</span></p>
</blockquote>
<h2 id="A-2-预训练过程">A.2 预训练过程</h2>
<p>为了生成每个训练输入序列，我们从语料库中采样两段文本，我们将其称为“句子”，尽管它们通常比单个句子长得多（但也可以更短）。第一个句子接收 A 嵌入，第二个句子接收 B 嵌入。 50% 的情况下 B 是 A 之后的实际下一个句子，50% 的情况下它是随机句子，这是为了“<strong>下一句预测</strong>”任务而完成的。对它们进行采样，使组合长度≤512个token。在<strong>WordPiece</strong>标记化之后应用LM掩蔽，统一掩蔽率为15%，并且不对部分词片进行特殊考虑。</p>
<p>我们使用 256 个序列的批量大小（256 个序列*512个标记=128,000个token/batch）进行1,000,000个步骤的训练，这大约是33亿单词语料库中的 40个epoch。我们使用Adam，学习率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>4</mn></mrow></msup><mtext>，</mtext><msub><mi>β</mi><mn>1</mn></msub><mo>=</mo><mn>0.9</mn><mtext>，</mtext><msub><mi>β</mi><mn>2</mn></msub><mo>=</mo><mn>0.999</mn><mtext>，</mtext><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">1e^{-4}，β_1 = 0.9，β_2 = 0.999，L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0.9</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord">0.999</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>权重衰减为0.01，前10,000个步骤的<strong>学习率预热</strong>，以及学习率的<strong>线性衰减</strong>。我们在所有层上使用0.1的dropout概率。我们遵循 OpenAI GPT，使用<strong>gelu激活函数</strong>而不是标准relu。训练损失是平均屏蔽 LM 似然以及平均下一句预测似然之和。</p>
<blockquote>
<p>学习率warm up+线性衰减就是先升后减。</p>
</blockquote>
<p>BERT<sub>BASE</sub> 的训练在<a target="_blank" rel="noopener" href="https://cloudplatform.googleblog.com/2018/06/CloudTPU-now-offers-preemptible-pricing-and-globalavailability.html">Pod配置</a>中的4个云TPU上进行（总共16个TPU 芯片。）。BERT<sub>LARGE</sub>的训练在 16 个云TPU上进行（总共 64个TPU 芯片）。每次预训练需要 4 天才能完成。</p>
<p>较长的序列成本过高，因为注意力与序列长度成二次方。为了加快实验中的预训练速度，我们对90%的步骤使用序列长度为128的模型进行预训练。然后，其余10%步骤我们训练512序列长度来学习位置嵌入。</p>
<h2 id="A-3-微调过程">A.3 微调过程</h2>
<p>对于微调，大多数模型超参数与预训练中的相同，除了批量大小、学习率和训练轮数之外。丢失概率始终保持在 0.1。最佳超参数值是特定于任务的，但我们发现以下可能值范围适用于所有任务：</p>
<ul>
<li><strong>Batch size</strong>: 16, 32</li>
<li><strong>Learning rate</strong> (Adam): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li><strong>Number of epochs</strong>: 2, 3, 4</li>
</ul>
<p><font color="red">我们还观察到，大数据集（例如，100k+ 标记的训练示例）对超参数选择的敏感度远低于小数据集。</font>微调通常非常快，因此只需对上述参数进行详尽的搜索并选择在开发集上表现最佳的模型是合理的。</p>
<h2 id="A-4-BERT、ELMo-和-OpenAI-GPT-的比较">A.4 BERT、ELMo 和 OpenAI GPT 的比较</h2>
<p>在这里，我们研究了最近流行的表示学习模型（包括 ELMo、OpenAI GPT 和 BERT）的差异。模型架构之间的比较如图 3 所示。请注意，除了架构差异之外，BERT 和 OpenAI GPT 都是微调方法，而 ELMo 是基于特征的方法。</p>
<p>与 BERT 最相似的现有预训练方法是 OpenAI GPT，它在大型文本语料库上训练从左到右的 Transformer LM。<font color="red">事实上，BERT 中的许多设计决策都是有意使其尽可能接近 GPT，以便最大限度地比较这两种方法。</font>这项工作的核心论点是，第 3.1 节中提出的双向性和两个预训练任务占了大部分实证改进的份额，但我们确实注意到 BERT 和 GPT 的训练方式还存在其他几个差异：</p>
<ul>
<li>GPT 在 BooksCorpus（8 亿字）上进行训练； BERT 在 BooksCorpus（8 亿字）和维基百科（2,500M 字）上进行训练。</li>
<li>GPT 使用句子分隔符（[SEP]）和分类器标记（[CLS]），仅在微调时引入； BERT 在预训练期间学习 [SEP]、[CLS] 和句子 A/B 嵌入。</li>
<li>GPT 经过 1M 步骤的训练，批量大小为 32,000 个单词； BERT 接受了 1M 步的训练，批量大小为 128,000 个单词。</li>
<li>GPT 对所有微调实验使用相同的学习率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><msup><mi>e</mi><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5e^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>$； BERT 选择特定于任务的微调学习率，使其在开发集上表现最佳。</li>
</ul>
<p>为了隔离这些差异的影响，我们在第 5.1 节中进行了消融实验，该实验证明大部分改进实际上来自两个预训练任务及其实现的双向性。</p>
<h2 id="A-5-不同任务微调说明">A.5 不同任务微调说明</h2>
<p>图 4 展示了在不同任务上微调 BERT 的情况。我们的特定任务模型是通过将 BERT 与一个额外的输出层相结合而形成的，因此需要从头开始学习最少数量的参数。其中，（a）和（b）是<strong>序列级任务</strong>，而（c）和（d）是<strong>令牌级任务</strong>。图中，E表示输入嵌入，T<sub>i</sub>表示token i的上下文表示，[CLS]是分类输出的特殊符号，[SEP]是分隔非连续token序列的特殊符号。</p>
<h1>B 详细的实验设置</h1>
<h2 id="B-1-GLUE-基准实验的详细描述。">B.1 GLUE 基准实验的详细描述。</h2>
<p>表 1 中的 GLUE 结果来自 <a target="_blank" rel="noopener" href="https://gluebenchmark.com/leaderboard">https://gluebenchmark.com/leaderboard</a> 和 <a target="_blank" rel="noopener" href="https://blog.openai.com/language-unsupervised%E3%80%82">https://blog.openai.com/language-unsupervised。</a> GLUE 基准包括以下数据集，其描述最初由 Wang 等人 (2018a)总结：</p>
<p><strong>MNLI</strong> 多流派自然语言推理是一项大规模、众包蕴涵分类任务 (Williams et al., 2018)。给定一对句子，目标是预测第二个句子相对于第一个句子是否是<strong>蕴涵</strong>、<strong>矛盾</strong>或<strong>中性</strong>。</p>
<p><strong>QQP Quora</strong> 问题对是一项二元分类任务，其目标是确定 Quora 上提出的两个问题在语义上是否等效（Chen 等人，2018）。</p>
<p><strong>QNLI</strong> 问题自然语言推理是斯坦福问答数据集（Rajpurkar 等人，2016）的一个版本，已转换为二元分类任务（Wang 等人，2018a）。正例是包含正确答案的（问题，句子）对，负例是来自同一段落的不包含答案的（问题，句子）。</p>
<p><img src="152803733.png" alt></p>
<center>图 4：在不同任务上微调 BERT 的图示。</center>
<p><strong>SST-2</strong> 斯坦福情感树库是一个二元单句分类任务，由从电影评论中提取的句子以及人类对其情感的注释组成（Socher 等人，2013）。</p>
<p><strong>CoLA</strong> 语言可接受性语料库是一项二元单句分类任务，其目标是预测英语句子在语言上是否“可接受”（Warstadt et al., 2018）。</p>
<p><strong>STS-B</strong> 语义文本相似度基准是从新闻标题和其他来源提取的句子对的集合（Cer 等人，2017）。它们被标注了从 1 到 5 的分数，表示两个句子在语义上的相似程度。</p>
<p><strong>MRPC</strong> 微软研究释义语料库由从在线新闻源自动提取的句子对组成，并通过人工注释来判断该对中的句子在语义上是否等效（Dolan 和 Brockett，2005）。</p>
<p><strong>RTE</strong> 识别文本蕴涵是类似于 MNLI 的二元蕴涵任务，但训练数据要少得多（Bentivogli 等人，2009）。14</p>
<p><strong>WNLI</strong> Winograd NLI 是一个小型自然语言推理数据集（Levesque 等人，2011）。 GLUE 网页指出，该数据集的构建存在问题，15 并且提交给 GLUE 的每个经过训练的系统的表现都低于预测多数类的 65.1 基线精度。因此，为了对 OpenAI GPT 公平，我们排除了该集合。对于我们提交的 GLUE，我们总是预测多数类</p>
<h1>C 附加消融研究</h1>
<h2 id="C-1-训练步骤数量的影响">C.1 训练步骤数量的影响</h2>
<p>图 5 显示了从已预训练 k 个步骤的检查点进行微调后的 MNLI Dev 准确度。这让我们可以回答以下问题：</p>
<ol>
<li>问：BERT 真的需要这么大量的预训练（128,000 个单词/batch * 1,000,000 步骤）才能达到很高的微调精度吗？答案：是的，与 500k 步相比，在 1M 步训练时，BERTBASE 在 MNLI 上实现了近 1.0% 的额外准确率。</li>
<li>问：MLM 预训练的收敛速度是否比 LTR 预训练慢，因为每批中只预测了 15% 的单词，而不是每个单词？答案：MLM 模型的收敛速度确实比 LTR 模型稍慢。然而，就绝对精度而言，MLM 模型几乎立即开始优于 LTR 模型。</li>
</ol>
<h2 id="C-2-不同屏蔽程序的消融">C.2 不同屏蔽程序的消融</h2>
<p>在第 3.1 节中，我们提到 BERT 在使用屏蔽语言模型（MLM）目标进行预训练时使用混合策略来屏蔽目标标记。以下是评估不同掩蔽策略效果的消融研究。</p>
<p><img src="153405216.png" alt></p>
<center>图 5：训练步骤数的消融。这显示了从已预训练 k 步骤的模型参数开始进行微调后的 MNLI 准确度。 x 轴是 k 的值。</center>
<p><font color="red">请注意，掩蔽策略的目的是减少预训练和微调之间的不匹配，因为 [MASK] 符号在微调阶段永远不会出现。</font>我们报告 MNLI 和 NER 的开发结果。对于 NER，我们报告了微调和基于特征的方法，因为我们预计基于特征的方法的不匹配将会被放大，因为模型将没有机会调整表示。</p>
<p><img src="153539926.png" alt></p>
<center>表 8：不同掩蔽策略的消融。</center>
<p>结果如表8所示。表中，MASK表示我们将目标token替换为MLM的[MASK]符号； <strong>SAME</strong>意味着我们保持目标token不变； <strong>RND</strong>意味着我们用另一个随机token替换目标token。表左侧的数字代表MLM预训练时使用的具体策略的概率（BERT使用80%、10%、10%）。论文的右侧部分代表开发集结果。对于基于特征的方法，我们将 BERT 的最后4层连接起来作为特征，这在 5.3 节中被证明是最好的方法。从表中可以看出，微调对于不同的掩蔽策略具有惊人的鲁棒性。然而，正如预期的那样，在将基于特征的方法应用于NER 时，仅使用 MASK 策略是有问题的。有趣的是，仅使用RND策略的性能也比我们的策略差得多。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HUI</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/22/paper/Bert/">http://example.com/2024/09/22/paper/Bert/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HUI</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/IEKTIWS4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/22/huggingface_course/Diffusion_Course(1)/" title="Diffusion课程（一）- 介绍"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Diffusion课程（一）- 介绍</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/21/hexo/hexo/" title="使用hexo+github搭建个人博客"><img class="cover" src="/img/favicon.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用hexo+github搭建个人博客</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/87788970_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUI</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kalabiqlx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:kalabiqlx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">摘要：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">2. 相关工作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%97%A0%E7%9B%91%E7%9D%A3%E7%9A%84%E5%9F%BA%E4%BA%8E%E7%89%B9%E5%BE%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2.1 无监督的基于特征的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-text">2.2 无监督微调方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BB%8E%E6%9C%89%E6%A0%87%E8%AE%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8A%E5%81%9A%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0"><span class="toc-text">2.3 从有标记的数据上做迁移学习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">3. BERT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%A2%84%E8%AE%AD%E7%BB%83BERT"><span class="toc-text">3.1 预训练BERT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%BE%AE%E8%B0%83BERT"><span class="toc-text">3.2 微调BERT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">4. 实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E7%90%86%E8%A7%A3%E8%AF%84%E4%BC%B0%EF%BC%88GLUE%EF%BC%89"><span class="toc-text">4.1 通用语言理解评估（GLUE）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%96%AF%E5%9D%A6%E7%A6%8F%E9%97%AE%E7%AD%94%E6%95%B0%E6%8D%AE%E9%9B%86-SQuAD-v1-1"><span class="toc-text">4.2 斯坦福问答数据集 (SQuAD v1.1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-SQuAD-v2-0"><span class="toc-text">4.3 SQuAD v2.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-SWAG"><span class="toc-text">4.4 SWAG</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">5. 消融研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%A2%84%E8%AE%AD%E7%BB%83%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">5.1 预训练任务的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%A8%A1%E5%9E%8B%E8%A7%84%E6%A8%A1%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">5.2 模型规模的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-BERT-%E7%9A%84%E5%9F%BA%E4%BA%8E%E7%89%B9%E5%BE%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.3 BERT 的基于特征的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">6. 结论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">附录：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">A.BERT的附加细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-1-%E9%A2%84%E8%AE%AD%E7%BB%83%E4%BB%BB%E5%8A%A1%E8%AF%B4%E6%98%8E"><span class="toc-text">A.1 预训练任务说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-2-%E9%A2%84%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B"><span class="toc-text">A.2 预训练过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-3-%E5%BE%AE%E8%B0%83%E8%BF%87%E7%A8%8B"><span class="toc-text">A.3 微调过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-4-BERT%E3%80%81ELMo-%E5%92%8C-OpenAI-GPT-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">A.4 BERT、ELMo 和 OpenAI GPT 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-5-%E4%B8%8D%E5%90%8C%E4%BB%BB%E5%8A%A1%E5%BE%AE%E8%B0%83%E8%AF%B4%E6%98%8E"><span class="toc-text">A.5 不同任务微调说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">B 详细的实验设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-1-GLUE-%E5%9F%BA%E5%87%86%E5%AE%9E%E9%AA%8C%E7%9A%84%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="toc-text">B.1 GLUE 基准实验的详细描述。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">C 附加消融研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-1-%E8%AE%AD%E7%BB%83%E6%AD%A5%E9%AA%A4%E6%95%B0%E9%87%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">C.1 训练步骤数量的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-2-%E4%B8%8D%E5%90%8C%E5%B1%8F%E8%94%BD%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B6%88%E8%9E%8D"><span class="toc-text">C.2 不同屏蔽程序的消融</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/12/paper/U-Net/" title="U-Net精读"><img src="/img/pob5vjumok.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="U-Net精读"/></a><div class="content"><a class="title" href="/2024/10/12/paper/U-Net/" title="U-Net精读">U-Net精读</a><time datetime="2024-10-12T06:05:38.000Z" title="发表于 2024-10-12 14:05:38">2024-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/10/exercitation/all/" title="八股文-杂七杂八">八股文-杂七杂八</a><time datetime="2024-10-10T12:55:33.000Z" title="发表于 2024-10-10 20:55:33">2024-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/10/exercitation/bagu_DeepLearning(1)/" title="八股文-深度学习(一)">八股文-深度学习(一)</a><time datetime="2024-10-10T12:55:33.000Z" title="发表于 2024-10-10 20:55:33">2024-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/10/exercitation/bagu_CV(1)/" title="八股文-计算机视觉(一)">八股文-计算机视觉(一)</a><time datetime="2024-10-10T12:55:33.000Z" title="发表于 2024-10-10 20:55:33">2024-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/10/exercitation/bagu_NLP(1)/" title="八股文-自然语言处理(一)">八股文-自然语言处理(一)</a><time datetime="2024-10-10T12:55:33.000Z" title="发表于 2024-10-10 20:55:33">2024-10-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/IEKTIWS4.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By HUI</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2024/09/22/paper/Bert/'
    this.page.identifier = '/2024/09/22/paper/Bert/'
    this.page.title = 'Bert原文笔记'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>
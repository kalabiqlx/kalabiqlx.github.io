<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Audio课程（三）- 音频Transformer架构 | HUI</title><meta name="author" content="HUI"><meta name="copyright" content="HUI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="转载自：https:&#x2F;&#x2F;huggingface.co&#x2F;learn&#x2F;audio-course&#x2F;en&#x2F;  Audio课程（三）- 音频Transformer架构 本课程中，我们主要关注Transformer模型以及它们如何应用于音频任务。虽然您不需要了解这些模型的内部细节，但了解使它们工作的主要概念很有用，因此我们在本小节中回顾一下关于Transformer的知识。有关transformer的深入了解">
<meta property="og:type" content="article">
<meta property="og:title" content="Audio课程（三）- 音频Transformer架构">
<meta property="og:url" content="http://example.com/2024/10/08/huggingface_course/Audio_Course(3)/index.html">
<meta property="og:site_name" content="HUI">
<meta property="og:description" content="转载自：https:&#x2F;&#x2F;huggingface.co&#x2F;learn&#x2F;audio-course&#x2F;en&#x2F;  Audio课程（三）- 音频Transformer架构 本课程中，我们主要关注Transformer模型以及它们如何应用于音频任务。虽然您不需要了解这些模型的内部细节，但了解使它们工作的主要概念很有用，因此我们在本小节中回顾一下关于Transformer的知识。有关transformer的深入了解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/43670b.png">
<meta property="article:published_time" content="2024-10-08T14:39:33.000Z">
<meta property="article:modified_time" content="2024-10-08T14:37:34.237Z">
<meta property="article:author" content="HUI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/43670b.png"><link rel="shortcut icon" href="/img/122061154_p0_master1200.jpg"><link rel="canonical" href="http://example.com/2024/10/08/huggingface_course/Audio_Course(3)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Audio课程（三）- 音频Transformer架构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-08 22:37:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bronya.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/87788970_p0_master1200.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/43670b.png')"><nav id="nav"><span id="blog-info"><a href="/" title="HUI"><img class="site-icon" src="/img/319E33068A7ED73BAE7EB48FCE321DD4.jpg"/><span class="site-name">HUI</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清單</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友鏈</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Audio课程（三）- 音频Transformer架构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-08T14:39:33.000Z" title="发表于 2024-10-08 22:39:33">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-08T14:37:34.237Z" title="更新于 2024-10-08 22:37:34">2024-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/HuggingFace/">HuggingFace</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/HuggingFace/Audio/">Audio</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Audio课程（三）- 音频Transformer架构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/10/08/huggingface_course/Audio_Course(3)/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2024/10/08/huggingface_course/Audio_Course(3)/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>转载自：<a target="_blank" rel="noopener" href="https://huggingface.co/learn/audio-course/en/">https://huggingface.co/learn/audio-course/en/</a></p>
<h1 id="audio课程三-音频transformer架构"><a class="markdownIt-Anchor" href="#audio课程三-音频transformer架构"></a> Audio课程（三）- 音频Transformer架构</h1>
<p>本课程中，我们主要关注Transformer模型以及它们如何应用于音频任务。虽然您不需要了解这些模型的内部细节，但了解使它们工作的主要概念很有用，因此我们在本小节中回顾一下关于Transformer的知识。有关transformer的深入了解，请查看我们的<a target="_blank" rel="noopener" href="https://huggingface.co/course/chapter1/1">NLP课程</a>。</p>
<h1 id="transformer模型回顾"><a class="markdownIt-Anchor" href="#transformer模型回顾"></a> Transformer模型回顾</h1>
<h2 id="1transformer的原理是什么"><a class="markdownIt-Anchor" href="#1transformer的原理是什么"></a> 1.Transformer的原理是什么？</h2>
<p>Transformer架构最早是为<strong>文本翻译</strong>的任务而设计的。它的结构如下：</p>
<p><img src="transformers.svg" alt></p>
<p>左边是<strong>编码器</strong>（encoder），右边是<strong>解码器</strong>（decoder）。</p>
<ul>
<li>编码器负责接收模型的输入，本例中是一系列文本标记(toen)，并构建其表征（representation，或称特征，feature）。Transformer模型的编码器在经过训练后能够从输入中提取并<strong>理解信息</strong>。</li>
<li>解码器负责使用编码器生成的表征（特征向量）以及其他输入（先前预测的标记）来生成目标序列。Transformer模型的解码器在经过训练能够<strong>根据表征中蕴含的信息生成输出序列</strong>。在原始设计中，输出序列由文本标记组成。</li>
</ul>
<p>有的Transformer模型只使用编码器（适用于需要理解输入的任务，例如分类），或者只使用解码器（适用于生成文本的任务）。BERT就是一个只使用编码器的例子；GPT2则是一个只使用解码器的例子。</p>
<p>Transformer模型的一个关键特征是它们使用特殊的层，称为<strong>注意力层</strong>（attention layers）。这些层告诉模型在计算特征表示时，特别关注输入序列中的某些元素，而忽略其他元素。</p>
<h2 id="2使用transformer进行音频处理"><a class="markdownIt-Anchor" href="#2使用transformer进行音频处理"></a> 2.使用Transformer进行音频处理</h2>
<p>本课程中，我们将介绍的音频模型通常具有上图所示的标准Transformer架构，<font color="red">但会在输入或输出端稍作修改来适应音频而非文本序列。</font>由于所有这些模型本质上都是Transformer，因此它们的大部分架构都是相同的，主要区别在于它们的训练和使用方式。</p>
<p><img src="transformers_blocks-1726124776313-11.png" alt></p>
<p>对于音频任务，输入和/或输出序列可以是音频而非文本：</p>
<ul>
<li><strong>自动语音识别</strong>（ASR）：输入为语音，输出为文本。</li>
<li><strong>文本到语音</strong>（TTS）：输入为文本，输出为语音。</li>
<li><strong>语音分类</strong>：输入为语音，输出为类别概率——对于序列中的每个元素，或者对于整个序列的单个类别概率。</li>
<li><strong>语音转换或语音增强</strong>：输入和输出均为语音。</li>
</ul>
<p>有几种不同的方法可以将音频数据转换为Transformer能够处理的格式。主要的区别在于是使用音频的原始波形作为模型的输入序列，还是使用其时频谱作为输入序列。</p>
<h2 id="3模型的输入格式"><a class="markdownIt-Anchor" href="#3模型的输入格式"></a> 3.模型的输入格式</h2>
<p>音频模型的输入可以是文本或声音。我们的目标是将此输入转换为一个嵌入向量（embedding vector），以便Transformer架构可以处理。</p>
<h3 id="文本输入"><a class="markdownIt-Anchor" href="#文本输入"></a> 文本输入</h3>
<p><strong>文本到语音模型</strong>（TTS）接受文本作为输入。这与原始Transformer或任何其他NLP模型的工作方式相同：首先对文本进行标记化（tokenization），得到一系列文本标记。然后将此序列通过输入嵌入层，将标记转换为512维向量。然后将这些嵌入向量传递到Transformer编码器中。</p>
<h3 id="波形输入"><a class="markdownIt-Anchor" href="#波形输入"></a> 波形输入</h3>
<p><strong>自动语音识别模型</strong>（ASR）接受语音作为输入。为了使用Transformer解决ASR任务，我们首先需要以某种方式将音频转换为嵌入向量序列。</p>
<p><strong>Wav2Vec2</strong>和<strong>HuBERT</strong>一类的模型直接使用音频波形作为模型的输入。如您在<a target="_blank" rel="noopener" href="https://huggingface.co/learn/audio-course/zh-CN/chapter3/chapter1/introduction">音频数据章节</a>中所见，波形是一个浮点数序列，其中的每个数表示某个时间点的幅值。<font color="red">我们首先将原始波形标准化为零均值和单位方差的序列，这有助于标准化不同音量（振幅）的音频样本。</font></p>
<p><img src="wav2vec2-input-1726124793420-13.png" alt></p>
<p><font color="red">完成标准化后，我们将该波形序列被转换为嵌入向量序列。这是通过一个<strong>小型卷积神经网络</strong>（CNN）完成的，称为<strong>特征编码器</strong>（feature encoder）。该网络的每个卷积层都处理输入序列，对音频进行下采样（subsampling）以减少序列长度，直到最后一个卷积层输出512维向量，即每25毫秒音频的嵌入向量（embedding vector）。当输入序列被转换为这样的嵌入向量序列（embedding vector sequence）后，Transformer便可以像往常一样处理数据了。</font></p>
<h3 id="时频谱输入"><a class="markdownIt-Anchor" href="#时频谱输入"></a> 时频谱输入</h3>
<p><font color="red">使用原始波形作为输入的一个缺点是它们往往具有较长的序列长度。</font>例如，采样率为16 kHz的30秒音频输入的长度为<code>30 * 16000 = 480000</code>。长的序列需要在Transformer模型中进行更多的计算，因此会增加内存使用量。</p>
<p>因此，我们认为在大多数情况下原始音频并不是最有效率的表示音频输入的方式。通过使用<strong>时频谱</strong>（spectrogram），我们可以以更紧凑的形式表示相同数量的信息。</p>
<p><img src="whisper-input-1726124808359-15.png" alt></p>
<p><strong>Whisper</strong>等模型首先将波形转换为一个对数梅尔频谱图（log-mel spectrogram）。<font color="red">Whisper会将音频分成数个30秒的片段，每个片段的对数梅尔频谱图的形状为<code>(80, 3000)</code>，其中80是梅尔频率的数量，3000是序列的长度。通过将音频转换为对数梅尔频谱图，我们不仅减少了输入数据的数量，而且更重要的是，转换后的序列长度远远小于波形的长度。</font>最后，对数梅尔频谱图由一个<strong>小型CNN处理</strong>，转换为嵌入向量序列，然后像往常一样输入Transformer。</p>
<p><font color="red">无论是波形还是时频谱输入，我们都会先使用一个小型的神经网络在Transformer之前将输入转换为嵌入向量序列，然后由Transformer接管并完成其工作。</font></p>
<h2 id="4模型的输出格式"><a class="markdownIt-Anchor" href="#4模型的输出格式"></a> 4.模型的输出格式</h2>
<p>Transformer架构会输出一个<strong>隐藏状态向量</strong>（hidden-state vectors）的序列，也称为<strong>输出嵌入向量</strong>（output embedding）。我们的目标是将这些向量转换为文本或音频输出。</p>
<h3 id="文本输出"><a class="markdownIt-Anchor" href="#文本输出"></a> 文本输出</h3>
<p>自动语音识别模型的目标是预测一个文本标记（text token）的序列。<font color="red">这是通过在Transformer的输出上添加一个语言建模（language modeling）头——通常是一个单独的线性层———然后在transformer的输出上添加一个softmax来完成的。该输出预测的是词汇表中文本标记的概率。</font></p>
<h3 id="时频谱输出"><a class="markdownIt-Anchor" href="#时频谱输出"></a> 时频谱输出</h3>
<p><font color="red">对于生成音频的模型，例如文本到语音（TTS）模型，我们需要添加能够生成音频序列的层。通常会生成一个频谱图，然后使用另一个神经网络（称为<strong>声码器</strong>（vocoder））将该频谱图转换为波形。</font></p>
<p>举个例子，<strong>SpeechT5</strong> TTS模型的输出是一个768元素向量的序列。<font color="red">线性层将该序列投影到一个对数梅尔频谱图上。然后，一个由<strong>线性层</strong>和<strong>卷积层</strong>组成的<strong>后处理网络</strong>（post-net）会对频谱图进行降噪处理。最后，我们使用声码器生成输出的音频波形。</font></p>
<p><img src="speecht5-1726124829067-17.png" alt></p>
<blockquote>
<p>💡<font color="red">如果我们对波形进行短时傅里叶变换（STFT）得到其时频谱，我们可以通过其逆向过程（ISTFT）重新得到原始的波形。这是因为STFT生成的时频谱包含了幅值和相位两部分的信息，而这两部分信息都是重建波形所必需的。然而，音频深度学习模型所生成的时频谱往往仅包含了幅值信息。为了将这样的时频谱转化为波形，我们需要通过某种方式估计其相位信息，这便是声码器的功能。</font></p>
</blockquote>
<h3 id="波形输出"><a class="markdownIt-Anchor" href="#波形输出"></a> 波形输出</h3>
<p>除了生成时频谱作为中间输出的方法外，有些模型也可以直接生成波形输出。但是，目前🤗 Transformers中没有包含能够直接生成波形的模型。</p>
<h2 id="5小结"><a class="markdownIt-Anchor" href="#5小结"></a> 5.小结</h2>
<p>总结一下：大多数音频Transformer模型都是相似的——它们都是基于相同的Transformer架构和注意力层构建的。不过，有些模型只使用Transformer的编码器部分，而有些模型则同时使用编码器和解码器。</p>
<p>我们也学习了如何在Transformer模型中将音频作为输入或者输出。在ASR、TTS等音频任务中，我们可以改变模型中的部分输入层来将数据转换为嵌入向量序列，也可以改变一部分输出层来将生成的嵌入向量序列转化为输出格式，而Transformer的主体部分保持不变。</p>
<p>接下来，我们将学习几种不同的训练方法来训练一个自动语音识别模型。</p>
<h1 id="ctc结构"><a class="markdownIt-Anchor" href="#ctc结构"></a> CTC结构</h1>
<p><strong>CTC结构（Connectionist Temporal Classification）<strong>是一种仅使用Transformer编码器（encoder）结构的语音识别（ASR）模型。使用该架构的模型包括</strong>Wav2Vec2</strong>、<strong>HuBERT</strong>、<strong>M-CTC-T</strong>等等。</p>
<p>仅含编码器的Transformer（encoder-only Transformer）是最简单的Transformer，因为它只使用模型的编码器部分。编码器读取输入序列（音频波形）并将其映射到隐藏状态序列（sequence of hidden-states），也称为输出嵌入（output embedding）。</p>
<p>使用CTC模型时，我们对隐藏状态序列进行额外的线性映射以获得类标签预测。类标签为<strong>字母表中的字母</strong>（a、b、c，…）。这样，我们就能够使用一个很小的分类头来预测目标语言中的任何单词，因为词汇表（vocabulary）只需要包含26个字符加上一些特殊的标记。</p>
<p><img src="wav2vec2-ctc-1726126676709-34.png" alt></p>
<p>到目前为止，这与我们在NLP中使用BERT模型的做法非常相似：仅编码器的Transformer模型将文本标记映射到一系列编码器隐藏状态，然后我们应用线性映射，为每个隐藏状态预测一个类标签。</p>
<p>棘手的问题在于：在语音识别中，我们不知道音频输入和文本输出的<strong>对齐方式</strong>（alignment）。我们知道<font color="red">语音的顺序与文本的转录顺序相同（对齐是单调的），但我们不知道转录文本中的字符如何与音频对齐。这就是CTC算法的用武之地。</font></p>
<blockquote>
<p>💡 在NLP模型中，<strong>词汇表</strong>（vocabulary，也称字典）通常由数千个token组成，这些标记不仅描述单个字符，还描述单词的部分甚至整个单词。<font color="red">然而对于CTC模型，较小的词汇表效果最好，我们一般会将其保持在50个字符以下。</font>我们不关心字母的大小写，因此仅使用大写（或仅使用小写）就足够了。数字则被拼写为单词，例如<code>&quot;20&quot;</code>变成<code>&quot;twenty&quot;</code>。除了字母，我们还需要至少一个<strong>单词分隔符标记</strong>（空格，space）和一个<strong>填充标记</strong>（padding token）。与NLP模型一样，填充标记允许我们将多个示例组合成批次，但它也是模型将预测的沉默标记。在英语中，保留<code>'</code>字符也很有用——毕竟，<code>&quot;it's&quot;</code>和<code>&quot;its&quot;</code>的含义完全不同。</p>
</blockquote>
<h2 id="1我们到底该怎么对齐呢"><a class="markdownIt-Anchor" href="#1我们到底该怎么对齐呢"></a> 1.我们到底该怎么对齐呢？</h2>
<p>自动语音识别（ASR）涉及将音频作为输入并产生文本作为输出。我们有几种选择来预测文本：</p>
<ul>
<li>预测<strong>单个字母</strong></li>
<li>预测<strong>音素</strong>（phoneme）</li>
<li>预测<strong>单词标记</strong>（word token）</li>
</ul>
<p><font color="red">ASR模型会使用含有<code>(音频, 文字)</code>对的数据集进行训练，这些数据集的文字信息通常是人工转录的。通常，数据集不包含任何时间信息，也就是说，我们不知道输入和输出序列应该如何对齐。</font></p>
<p>假设我们有一个长度为一秒钟的音频文件。在<strong>Wav2Vec2</strong>中，模型首先使用CNN特征编码器对音频输入进行下采样，将其映射到较短的隐藏状态序列，其中每20毫秒的音频会对应一个隐藏状态向量（hidden-states vector）。对于一秒的音频，我们将生成的隐藏状态序列传递给Transformer编码器。<font color="red"> （从输入序列中提取的音频片段会有部分重叠，因此即使每20毫秒会生成一个隐藏状态向量，但每个向量实际上包含了25毫秒的音频信息。）</font></p>
<p>Transformer的编码器会对每个隐藏状态向量产生一个输出预测，因此我们从Transformer中得到一个长度同样为50的输出向量序列。该序列中的每个向量的维度为768. 因此，该示例中Transformer编码器的输出序列的形状为<code>(768, 50)</code>。<font color="red">每个预测值包含了25毫秒的音频信息，而音素（phoneme）通常会持续超过25毫秒。因此，我们这里预测音素的效果会好于预测整个单词。CTC在小词汇表上的效果更好，因此我们将预测字母。</font></p>
<p><img src="cnn-feature-encoder-1726126689960-36.png" alt></p>
<p>为了进行文本预测，我们使用一个线性层（<strong>“CTC头”</strong>）将768维的编码器输出映射到我们的字符标签。然后，模型会预测一个<code>(50, 32)</code>的张量，其中32是词汇表中的标记数。由于我们对序列中的每个特征都进行了一次预测，因此每秒音频会有50个字符预测。</p>
<p>然而，如果我们简单地每20毫秒预测一个字母，我们的预测结果可能会是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRIIONSAWWSOMEETHINGCLOSETOPANICONHHISOPPONENT<span class="string">&#x27;SSFAACEWHENTHEMANNFINALLLYRREECOGGNNIIZEDHHISSERRRRORR ...</span></span><br></pre></td></tr></table></figure>
<p>仔细观察这个输出，我们可以发现它看起来有一点像英语，但有很多重复的字母。<font color="red">这是因为我们的模型必须每20毫秒都输出一些东西，而如果某个字母的持续时间超过了20毫秒，模型就会输出重复的字母。</font>我们无法避免这种情况，特别是在训练时我们不知道转录文本的时间信息。而CTC就是一个帮助我们过滤重复字母的方法。</p>
<p>（在实际操作中，预测的序列还有可能包含很多<strong>填充标记</strong>（padding token），用于表示模型不太确定音频表示的是什么，或者用于表示字符之间的空白。为了清晰起见，我们从示例中删除了这些填充标记。<font color="red">音频片段之间的部分重叠</font>也是字符重复的另一个原因。）</p>
<h2 id="2ctc算法"><a class="markdownIt-Anchor" href="#2ctc算法"></a> 2.CTC算法</h2>
<p>CTC算法的关键在于使用一个特殊的标记，通常称为<strong>空白标记</strong>（blank token）。这是一个我们人为加入词汇表的额外标记。在这个例子中，空白标记被表示为<code>_</code>。我们用这个特殊的标记来表示字母组之间的<strong>硬边界</strong>。</p>
<p>CTC模型的完整输出类似于如下的序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B_R_II_O_N_||_S_AWW_|||||_S_OMEE_TH_ING_||_C_L_O_S_E||TO|_P_A_N_I_C_||_ON||HHI_S||_OP_P_O_N_EN_T_<span class="string">&#x27;SS||_F_AA_C_E||_W_H_EN||THE||M_A_NN_||||_F_I_N_AL_LL_Y||||_RREE_C_O_GG_NN_II_Z_ED|||HHISS|||_ER_RRR_ORR||||</span></span><br></pre></td></tr></table></figure>
<p>该序列中的<code>|</code>标记是<strong>单词分隔符</strong>。在这个例子中，我们使用<code>|</code>而不是空格作为单词分隔符，这样可以更容易地看出单词的分隔位置，但它们的作用是一样的。</p>
<p>CTC空白标记使我们能够过滤掉重复的字母。例如预测序列中的最后一个单词，<code>_ER_RRR_ORR</code>。如果没有CTC空白标记，这个单词看起来是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRRRORR</span><br></pre></td></tr></table></figure>
<p>如果我们简单地去掉非CTC结果中的重复字符，那么它就变成了<code>EROR</code>。显然这不是正确的拼写。但是有了CTC空白标记，我们就可以在每个字母组中去掉重复的字母：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ER_RRR_ORR</span><br></pre></td></tr></table></figure>
<p>变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ER_R_OR</span><br></pre></td></tr></table></figure>
<p>最后我们去掉空白标记<code>_</code>，得到最终的单词：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR</span><br></pre></td></tr></table></figure>
<p>如果我们将这种逻辑应用到整个文本，包括<code>|</code>，并将剩余的<code>|</code>字符替换为空格，那么最终的CTC解码输出会变成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRION SAW SOMETHING CLOSE TO PANIC ON HIS OPPONENT<span class="string">&#x27;S FACE WHEN THE MAN FINALLY RECOGNIZED HIS ERROR</span></span><br></pre></td></tr></table></figure>
<p><font color="red">总结一下，CTC模型对应每20毫秒的输入音频（包括部分重叠）会生成一个预测标记。这样的预测规则会生成很多重复的字母。利用CTC空白标记，我们可以轻松地移除这些重复的字母，而不会破坏单词的正确拼写。这是一种非常简单和方便的方法，可以解决输出文本与输入音频的对齐问题。</font></p>
<blockquote>
<p><font color="red">💡 在实际的Wav2Vec2模型中，CTC空白标记与填充标记是相同的。模型会预测很多这样的标记，例如当当前20毫秒的音频没有明确的字符可以预测时。使用相同的标记作为填充和CTC空白标记可以简化解码算法，并有助于保持词汇表的小规模。</font></p>
</blockquote>
<p>我们可以在Transomer编码模型简单地加入CTC：将编码器的输出序列进入一个线性层，该线性层将音频特征映射到词汇表。模型使用特殊的CTC损失进行训练。</p>
<p>CTC的一个缺点在于，它可能会输出<strong>听起来</strong>正确但<strong>拼写</strong>不正确的单词。毕竟，CTC分类头只考虑了单个字符，而没有处理整个单词。我们可以使用额外的语言模型来提高音频的转录质量。这个语言模型实际上是作为了CTC输出的拼写检查器。</p>
<h2 id="3wav2vec2-hubert-m-ctc-t等模型有什么区别"><a class="markdownIt-Anchor" href="#3wav2vec2-hubert-m-ctc-t等模型有什么区别"></a> 3.Wav2Vec2, HuBERT, M-CTC-T等模型有什么区别？</h2>
<p>所有基于Transformer的CTC模型的架构都非常相似：它们都使用<strong>Transformer编码器</strong>（但不使用解码器），并在最后使用一个CTC分类头。从架构上来说，它们的相似程度大于他们的不同程度。</p>
<p>Wav2Vec2和M-CTC-T之间的一个区别在于，前者使用<strong>原始音频波形</strong>，而后者使用<strong>梅尔时频谱（mel spectrogram）<strong>作为输入。这些模型还是为不同的目的而训练的。例如，M-CTC-T是为</strong>多语言语音识别</strong>而训练的，因此它的CTC头相对较大，包含了中文字符以及其他字母。</p>
<p>Wav2Vec2和HuBERT使用了完全相同的架构，但训练方式有很大的区别。Wav2Vec2的训练方式类似于BERT的掩码语言模型（masked language modeling），通过预测音频中被遮盖（mask）的音素来进行预训练。HuBERT则更进一步，学习预测“离散语音单元”（discrete speech unit），这类似于文本句子中的标记，因此可以使用已有的NLP技术来处理语音。</p>
<p>最后，我们在这里介绍的模型并非全部的Transformer CTC模型。还有很多其他的模型，但现在我们知道他们都使用了类似的原理。</p>
<h1 id="seq2seq结构"><a class="markdownIt-Anchor" href="#seq2seq结构"></a> Seq2Seq结构</h1>
<p>上一小节中介绍的CTC结构仅适用于Tranformer结构的编码器（encoder）部分。如果我们给模型添加一个解码器（decoder）构建一个自编码模型（autoencoder，也称编码-解码模型，encoder-decoder），这个模型也可以被称为<strong>序列到序列</strong>模型（sequence-to-sequence，简称<strong>seq2seq</strong>）。Seq2Seq模型将一种数据序列映射到另一种数据序列。</p>
<p><font color="red">在仅使用编码器的Transformer模型中，编码器为输入序列中的每个元素进行预测。因此，输入和输出序列的长度总是相同的。在CTC模型（如Wav2Vec2）的情况下，输入波形会被下采样，但我们仍然对下采样后的每个元素（对应20毫秒的音频）输出一个对应的预测标记，因此输入标记和输出的预测标记仍然是等长的。</font></p>
<p><font color="red">而在seq2seq模型中，输入和输出序列的长度可以不同。这使得seq2seq模型更适合文本摘要或翻译等的NLP任务，也同时适用于<strong>语音识别</strong>等音频任务。</font></p>
<p>Seq2Seq结构中的解码器（decoder）和编码器（encoder）非常类似，两者都使用自注意力（self-attention）作为主要的运算单元。但是解码器的任务与编码器不同。为了理解这一点，让我们看看seq2seq模型如何进行自动语音识别。</p>
<h2 id="1自动语音识别asr"><a class="markdownIt-Anchor" href="#1自动语音识别asr"></a> 1.自动语音识别(ASR)</h2>
<p>下图展示了<strong>Whisper</strong>模型的结构（图片来自<a target="_blank" rel="noopener" href="https://openai.com/blog/whisper/">OpenAI Whisper博客</a>）：</p>
<p><img src="whisper_architecture-1726137095591-42.svg" alt></p>
<p>看起来十分熟悉。左边是<strong>Transformer编码器</strong>。它以<strong>对数梅尔时频谱</strong>（log-mel spectrogram）作为输入，并对其进行编码，输出一个编码器隐藏状态序列（sequence of encoder hidden states），从中提取出输入语音的重要特征。这个隐藏状态张量代表了整个输入序列，并高效地编码了输入语音的“含义”。</p>
<blockquote>
<p><strong>💡 这些seq2seq模型通常使用时频谱作为输入。不过，seq2seq模型也可以直接使用音频波形作为输入。</strong></p>
</blockquote>
<p>编码器的输出被传递到右边的<strong>Transformer解码器</strong>，使用一种称为<strong>交叉注意力</strong>（cross-attention）的机制。交叉注意力与自注意力类似，不过此处注意力的对象是编码器的输出。在这之后，我们就不再需要编码器了。</p>
<p><font color="red">解码器会使用<strong>自回归</strong>（autoregressive）的方式来预测一个文本标记序列，每次只预测一个标记，从一个仅含有“起始”标记（Whisper使用<code>SOT</code>作为起始标记）的序列开始。在每个时间步，前一个时间步的输出序列会作为新的输入序列被传递给解码器。这样，解码器每次只会输出一个新的标记，逐步增长输出序列，直到预测出“结束”标记，或者达到最大时间步数。</font></p>
<p>虽然解码器的结构与编码器类似，但是解码器和编码器有两个主要的区别：</p>
<ol>
<li>解码器会使用交叉注意力机制，允许它查看编码器生成的对于输入序列的隐藏状态向量。</li>
<li>解码器的注意力是<strong>因果</strong>（causal）的——<font color="red">解码器不允许查看未来的信息。</font></li>
</ol>
<p>在这个架构中，解码器的功能类似于<strong>语言模型</strong>（language model），它处理编码器的隐藏状态表示，并生成相应的文本转录。这种方法比CTC更强大，甚至CTC结合外部语言模型也无法相比。Seq2Seq结构可以使用相同的训练数据和损失函数进行端到端（end-to-end）训练，从而提供更好的灵活性和更好的性能。</p>
<blockquote>
<p>💡 与CTC模型输出单个字母的序列不同，Whisper模型的输出是完整的单词或词素。它使用GPT-2的分词器，有50k+个不同的标记。因此，seq2seq模型可以输出比CTC模型更短的序列。</p>
</blockquote>
<p>Seq2Seq语音识别模型最常使用的损失函数为<strong>交叉熵损失</strong>（cross-entropy loss），因为我们通常把模型最终层的输出视为一个标记的概率分布。交叉熵损失通常与<a target="_blank" rel="noopener" href="https://huggingface.co/blog/how-to-generate">束搜索（beam search）</a>等技术结合使用，生成最终的序列。<font color="red">语音识别的度量标准是<strong>WER（word error rate）</strong>，它衡量将预测文本转换为目标文本所需的替换、插入和删除的数量。所需的操作越少说明预测结果越好。</font></p>
<h2 id="2文本到语音text-to-speechtts"><a class="markdownIt-Anchor" href="#2文本到语音text-to-speechtts"></a> 2.文本到语音（Text-to-speech，TTS）</h2>
<p>可能不会让你感到惊讶的是， Seq2Seq的TTS模型基本上和ASR模型相同，仅仅是将输入和输出的数据种类互换！Transformer编码器接收文本标记序列，并提取表示输入文本的隐藏状态序列。Transformer解码器使用交叉注意力机制，预测输出的时频谱序列。</p>
<blockquote>
<p>💡 时频谱图是通过对音频波形的连续时间切片进行频谱分析得到的。<font color="red">换句话说，时频谱图是一个序列，其中的元素是（对数梅尔）频谱，每个时间步一个。</font></p>
</blockquote>
<p><font color="red">在ASR模型里，解码器的初始输出序列是一个仅包含“起始”标记的序列。而在TTS模型里，我们可以使用一个长度为1，值全为0的时频谱序列来代替“起始”标记。</font>有了这个初始时频谱序列和编码器隐藏状态的交叉注意力，解码器就可以预测下一个时间步的时频谱，逐步增长时频谱序列。</p>
<p><img src="speecht5_decoding-1726126717391-38.png" alt></p>
<p>但我们的解码器怎样知道需要在什么时候停止呢？在<strong>SpeechT5</strong>模型中，解码器会预测第二个序列。<font color="red">这个序列包含当前时间步是否是最后一个时间步的概率。在推理时，如果这个概率超过某个阈值（比如0.5），我们就认为解码器在指示时频谱序列已经生成完毕，应该结束生成循环。</font></p>
<p>在解码器生成完整的时频谱序列后，SpeechT5会使用一个称为<strong>后处理网络</strong>（post-net）的模型对时频谱序列进行微调。后处理网络由几个<strong>卷积层</strong>组成，用于微调时频谱序列。</p>
<p>在训练TTS模型时，我们的生成目标是<strong>训练数据的时频谱图</strong>，损失函数为<strong>L1损失</strong>或<strong>最小二乘损失</strong>（mean square error，MSE）。在推理时，我们希望将输出的时频谱图转换为音频波形，这样我们就可以听到它。为此，我们需要使用一个外部模型，称为<strong>声码器</strong>（vocoder）。这个声码器不是seq2seq架构的一部分，而是单独训练的。</p>
<p>TTS任务的难点在于其<strong>一对多的映射</strong>。<font color="red">对于语音到文本的任务，每个输入语音只对应一个正确的输出文本，但是对于文本到语音的任务，输入文本可以映射到多个可能的语音。例如，不同的说话人可能会强调同一个句子中的不同部分。这使得TTS模型很难评估。因为这个原因，L1或MSE损失实际上并不是理想的损失函数，因为同一个文本可以映射到多种不同的时频谱序列。这就是为什么TTS模型通常会由人类听众进行评估的原因，使用的指标称为<strong>MOS（mean opinion score，平均意见分数）</strong>。</font></p>
<h2 id="3总结"><a class="markdownIt-Anchor" href="#3总结"></a> 3.总结</h2>
<p>Seq2Seq结构是一种强大的模型，其能力往往优于仅含编码器的模型。通过将输入序列的编码与输出序列的解码分离，我们可以很好地处理音频和文本的对齐问题。</p>
<p><font color="red">然而，编码器-解码器模型也存在一些<strong>缺点</strong>，比较重要的一点是其<strong>推理速度较慢</strong>。这是由于其解码过程在每一步仅生成一个输出元素，因此完整的预测需要进行数次推理。输出序列越长，推理的速度也就越慢。自回归模型也可能会陷入循环或者跳过一些元素。**束搜索（beam search）**等技术可以提高预测结果的质量，但也会进一步降低推理速度。</font></p>
<h1 id="音频分类结构"><a class="markdownIt-Anchor" href="#音频分类结构"></a> 音频分类结构</h1>
<p>音频分类任务的目标是预测音频输出的分类标签。<font color="red">分类模型可以为整个输入序列预测一个标签，也可以为每一帧预测一个不同的标签。在分帧预测时，模型通常为每20毫秒的输入音频预测一个标签，并生成一个由分类标签概率分布组成的序列。预测单一标签的例子如预测音频中发出声音的鸟的种类；预测分帧标签的例子如说话人识别，每帧都可能由不同的说话人在发出声音。</font></p>
<h2 id="1使用时频谱进行分类"><a class="markdownIt-Anchor" href="#1使用时频谱进行分类"></a> 1.使用时频谱进行分类</h2>
<p><font color="red">最简单的音频分类方法之一是将其视为一个图像分类问题！</font></p>
<p>回想一下，时频谱是一个形状为<code>（频率，序列长度）</code>的二维张量。在<a target="_blank" rel="noopener" href="https://huggingface.co/learn/audio-course/zh-CN/chapter3/chapter1/audio_data">音频数据章节</a>中，我们学习过将这些时频谱绘制为图像。没错，我们可以直接将时频谱视为图像，并将其传递给一个常见的CNN分类器模型，如ResNet，并获得非常好的预测结果。更好的是，也可以使用图像Transformer模型，如ViT。</p>
<p>这就是<strong>AST</strong>（Audio Spectrogram Transformer）的作用。它使用ViT（即Vision Transformer）模型，并使用时频谱而非常规图像作为输入。由于Transformer的自注意层，该模型能够比CNN更好地捕获全局上下文。</p>
<p>与ViT一样，AST模型将音频时频谱分成16×16像素的部分重叠的图像块（image patch）序列。然后，我们将此序列中的块投影到嵌入序列中，并像往常一样将其作为输入传递给Transformer编码器。AST是一个仅含编码器的Transformer模型，因此输出是一个隐藏状态序列，每个16×16输入块对应一个隐藏状态。最后是一个含有sigmoid激活函数的简单分类层，将<strong>隐藏状态</strong>映射为<strong>分类概率</strong>。</p>
<p><img src="ast-1726126734224-40.png" alt></p>
<p>图像来自论文<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2104.01778.pdf">AST: Audio Spectrogram Transformer</a></p>
<blockquote>
<p>💡 尽管在这里我们假装时频谱与图像相同，但它们之间其实有重要的区别。<font color="red">例如，将图像的内容上下平移通常不会改变图像中的内容的含义。然而，将时频谱上下平移将改变声音中的频率，并完全改变其特性。图像具有一定的上下和左右平移不变性（shift-invariance），但时频谱仅具有一定的左右平移不变性，而几乎完全不具有上下平移不变性。尽管在实践中，将时频谱视为图像可以得到很好的效果，但请记住它们在原理上完全不同。</font></p>
</blockquote>
<h2 id="2任何transformer都可以是分类器"><a class="markdownIt-Anchor" href="#2任何transformer都可以是分类器"></a> 2.任何Transformer都可以是分类器</h2>
<p>在<a target="_blank" rel="noopener" href="https://huggingface.co/learn/audio-course/zh-CN/chapter3/ctc">CTC</a>一节中，我们了解到CTC是一种使用仅含编码器的Transformer来执行自动语音识别的有效技术。CTC模型实际上已经可以被视为<strong>分类器</strong>，因为其预测的是词汇表中每个词素的概率。我们可以通过更改标签并使用常规的交叉熵损失函数代替特殊的CTC损失来将CTC模型转换为通用的音频分类器。</p>
<p>举个例子，HF Transformers库中包含了<code>Wav2Vec2ForCTC</code>模型，但提供了<code>Wav2Vec2ForSequenceClassification</code>和<code>Wav2Vec2ForAudioFrameClassification</code>。这些模型之间的唯一区别是分类层的大小和所使用的损失函数。</p>
<p><font color="red">实际上，任何仅含编码器的音频Transformer模型都可以通过在隐藏状态序列之上添加分类层来转换为音频分类器。分类任务通常不需要Transformer解码器。</font></p>
<p>如果需要对<strong>整个序列</strong>输出一个单独的分类标签（<code>Wav2Vec2ForSequenceClassification</code>），模型会对隐藏状态序列沿其长度取<strong>平均值</strong>，并将其输送到分类层。这样我们就可以对整个序列输出一个概率分布，而不是输出序列中每个元素的概率分布。</p>
<p>如果需要对<strong>每一帧</strong>输出一个分类标签（<code>Wav2Vec2ForAudioFrameClassification</code>），我们就让分类器对隐藏状态序列中的<font color="red">每个元素都输出一个概率分布，这样我们的输出会成为一个具有同样长度的概率分布序列。</font></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">HUI</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/08/huggingface_course/Audio_Course(3)/">http://example.com/2024/10/08/huggingface_course/Audio_Course(3)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HUI</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/43670b.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/08/huggingface_course/Audio_Course(4)/" title="Audio课程（四）- 构建音频流派分类器"><img class="cover" src="/img/43670b.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Audio课程（四）- 构建音频流派分类器</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/08/huggingface_course/Audio_Course(2)/" title="Audio课程（二）- 音频应用的入门介绍"><img class="cover" src="/img/43670b.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Audio课程（二）- 音频应用的入门介绍</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/87788970_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HUI</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kalabiqlx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:kalabiqlx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#audio%E8%AF%BE%E7%A8%8B%E4%B8%89-%E9%9F%B3%E9%A2%91transformer%E6%9E%B6%E6%9E%84"><span class="toc-text"> Audio课程（三）- 音频Transformer架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#transformer%E6%A8%A1%E5%9E%8B%E5%9B%9E%E9%A1%BE"><span class="toc-text"> Transformer模型回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1transformer%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text"> 1.Transformer的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8transformer%E8%BF%9B%E8%A1%8C%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86"><span class="toc-text"> 2.使用Transformer进行音频处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 3.模型的输入格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5"><span class="toc-text"> 文本输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%85%A5"><span class="toc-text"> 波形输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%A2%91%E8%B0%B1%E8%BE%93%E5%85%A5"><span class="toc-text"> 时频谱输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text"> 4.模型的输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA"><span class="toc-text"> 文本输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%A2%91%E8%B0%B1%E8%BE%93%E5%87%BA"><span class="toc-text"> 时频谱输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A2%E5%BD%A2%E8%BE%93%E5%87%BA"><span class="toc-text"> 波形输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%B0%8F%E7%BB%93"><span class="toc-text"> 5.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ctc%E7%BB%93%E6%9E%84"><span class="toc-text"> CTC结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E6%80%8E%E4%B9%88%E5%AF%B9%E9%BD%90%E5%91%A2"><span class="toc-text"> 1.我们到底该怎么对齐呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2ctc%E7%AE%97%E6%B3%95"><span class="toc-text"> 2.CTC算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3wav2vec2-hubert-m-ctc-t%E7%AD%89%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text"> 3.Wav2Vec2, HuBERT, M-CTC-T等模型有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seq2seq%E7%BB%93%E6%9E%84"><span class="toc-text"> Seq2Seq结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E8%87%AA%E5%8A%A8%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%ABasr"><span class="toc-text"> 1.自动语音识别(ASR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E6%96%87%E6%9C%AC%E5%88%B0%E8%AF%AD%E9%9F%B3text-to-speechtts"><span class="toc-text"> 2.文本到语音（Text-to-speech，TTS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E6%80%BB%E7%BB%93"><span class="toc-text"> 3.总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E5%88%86%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-text"> 音频分类结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E4%BD%BF%E7%94%A8%E6%97%B6%E9%A2%91%E8%B0%B1%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="toc-text"> 1.使用时频谱进行分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E4%BB%BB%E4%BD%95transformer%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-text"> 2.任何Transformer都可以是分类器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/LLM/MoE/" title="大模型系列(三)- MoE:混合专家模型"><img src="/img/image-20241028124915950.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大模型系列(三)- MoE:混合专家模型"/></a><div class="content"><a class="title" href="/2024/10/28/LLM/MoE/" title="大模型系列(三)- MoE:混合专家模型">大模型系列(三)- MoE:混合专家模型</a><time datetime="2024-10-28T05:31:38.000Z" title="发表于 2024-10-28 13:31:38">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/23/LLM/RLHF/" title="大模型系列(二)- RLHF:基于人类反馈的强化学习"><img src="/img/image-20241023152702443.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大模型系列(二)- RLHF:基于人类反馈的强化学习"/></a><div class="content"><a class="title" href="/2024/10/23/LLM/RLHF/" title="大模型系列(二)- RLHF:基于人类反馈的强化学习">大模型系列(二)- RLHF:基于人类反馈的强化学习</a><time datetime="2024-10-23T05:31:38.000Z" title="发表于 2024-10-23 13:31:38">2024-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/Multimodel/multimodel_summerize/" title="多模态系列(七)- 总结"><div style="background: /img/"></div></a><div class="content"><a class="title" href="/2024/10/22/Multimodel/multimodel_summerize/" title="多模态系列(七)- 总结">多模态系列(七)- 总结</a><time datetime="2024-10-22T08:48:35.000Z" title="发表于 2024-10-22 16:48:35">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/Multimodel/BEiTv3/" title="多模态系列(六)- BEiTv3"><img src="/img/image-20241022190456136.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多模态系列(六)- BEiTv3"/></a><div class="content"><a class="title" href="/2024/10/22/Multimodel/BEiTv3/" title="多模态系列(六)- BEiTv3">多模态系列(六)- BEiTv3</a><time datetime="2024-10-22T07:48:38.000Z" title="发表于 2024-10-22 15:48:38">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/Multimodel/COCA/" title="多模态系列(五)- COCA"><img src="/img/image-20241022153206496.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多模态系列(五)- COCA"/></a><div class="content"><a class="title" href="/2024/10/22/Multimodel/COCA/" title="多模态系列(五)- COCA">多模态系列(五)- COCA</a><time datetime="2024-10-22T06:51:38.000Z" title="发表于 2024-10-22 14:51:38">2024-10-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/43670b.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By HUI</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2024/10/08/huggingface_course/Audio_Course(3)/'
    this.page.identifier = '/2024/10/08/huggingface_course/Audio_Course(3)/'
    this.page.title = 'Audio课程（三）- 音频Transformer架构'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !false) {
    if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>